{"version":3,"sources":["../../src/theme/typography.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/view/view.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/hooks/useTextAccessibility.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/touchable/touchable.js","../../node_modules/keg-core/node_modules/react-native-svg-web/index.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/svgIcon/svgIcon.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/typography/p.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/form/checkbox/checkbox.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/hooks/useChildrenWithRefs.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/list/scrollView.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/drawer/drawer.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/form/checkGroup/checkGroup.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/form/select/select.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/form/switch/switch.js","../../node_modules/keg-core/node_modules/@keg-hub/keg-components/src/components/link/link.js","../../src/reducers/initialStates/sessions.js","../../src/reducers/initialStates/pendingSession.js","../../src/reducers/initialStates/settings.js","../../node_modules/keg-core/core/base/native/keyStore/baseStorage.js","../../node_modules/keg-core/core/base/native/keyStore/keyStore.web.js","../../node_modules/keg-core/core/base/store/plugins/localStorage.js","../../node_modules/keg-core/core/base/store/plugins/index.js","../../src/components/modals/baseModal.js","../../src/utils/logs/devLog.js","../../src/assets/icons/evf/elements/digit.js","../../src/utils/models/sessions/getDisabled.js","../../node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js","../../node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js","../../node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js","../../node_modules/date-fns/esm/locale/en-US/_lib/match/index.js","../../node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js","../../node_modules/date-fns/esm/_lib/format/lightFormatters/index.js","../../node_modules/date-fns/esm/_lib/format/formatters/index.js","../../node_modules/date-fns/esm/_lib/format/longFormatters/index.js","../../node_modules/date-fns/esm/format/index.js","../../src/utils/models/sessions/getBookingState.js","../../src/components/button/evfButton.js","../../src/hooks/booking/useRestrictedAttendeeIds.js","../../src/hooks/booking/useBookingTimeConflicts.js","../../src/hooks/models/attendees/useIsAttendeeDisabledCallback.js","../../src/components/booking/attendeeBookingList.js","../../src/components/booking/groupBookingSection.js","../../src/components/booking/groupBookingOptions.js","../../node_modules/keg-core/core/base/utils/events/event_emitter.js","../../src/actions/modals/showAlertModal.js","../../src/components/booking/groupBooker.js","../../src/hooks/booking/useBookingLists.js","../../src/hooks/booking/useGroupCounts.js","../../src/components/modals/groupBooking.js","../../node_modules/keg-core/core/base/utils/storage/loadFromLocalStorage.js","../../src/components/labels/labelButton.js","../../src/actions/session/filters/updateSelectedFilters.js","../../src/actions/session/booking/setWaitingListActive.js","../../src/actions/session/setAgendaSessions.js","../../src/actions/session/filters/applySessionFilters.js","../../src/actions/session/filters/cancelSelectedFilters.js","../../src/hooks/sessions/useFilteredSessions.js","../../src/components/modals/filter.js","../../src/components/modals/alert.js","../../src/components/labels/labelList.js","../../src/actions/session/selectSession.js","../../src/hooks/booking/useBookingState.js","../../src/components/button/bookingButton.js","../../src/components/modals/modalManager.js","../../src/actions/session/mapSessionInterface.js","../../src/components/grid/emptyDayMessage.js","../../src/components/labels/labelTag.js","../../src/components/sessionTime/sessionTime.js","../../src/components/sessionLink/sessionLink.js","../../src/components/grid/gridRowContent.js","../../src/components/grid/gridTileContent.js","../../src/components/grid/gridItem.js","../../src/containers/gridContainer.js","../../src/components/dates/updateDayButton.js","../../src/components/dates/dayToggle.js","../../src/actions/session/dates/setDay.js","../../src/components/sessionsHeader/sessionsHeader.js","../../src/components/sessionsList/sessionsList.js","../../node_modules/keg-core/node_modules/resolve-pathname/esm/resolve-pathname.js","../../node_modules/keg-core/node_modules/history/esm/history.js","../../src/actions/session/initSessions.js","mocks/text.js","mocks/testData.js","mocks/evfButton.js","EvfSessions.js","mocks/evfModalBuilder.js","App.js","serviceWorker.js","index.js"],"names":["buildTypography","View","c","Touchable","createElement","name","type","Svg","Checkbox","ScrollView","CheckGroup","BaseModal","devLog","i","formatDistanceLocale","dirtyNumber","_dirtyOptions","formatTimezoneShort","offset","dirtyDelimiter","formatTimezoneWithOptionalMinutes","formatTimezone","dateLongFormatter","pattern","formatLong","timeLongFormatter","longFormatters","formattingTokensRegExp","cleanEscapedString","input","GroupBookerBody","LabelButton","LabelList","LabelTag","SessionTime","GridRowContent","GridTileContent","GridItem","UpdateDayButton","DayToggle","isAbsolute","pathname","spliceOne","list","index","createPath","location","createLocation","path","state","key","currentLocation","clamp","n","lowerBound","upperBound","longText","displayProperties","dateFormat","timeFormat","agendaDays","dayNumber","date","dayName","settings","showLocationInAgenda","showPresentersInAgenda","presenters","identifier","title","firstname","lastname","email","jobtitle","company","photographUrl","biography","labels","className","locations","sessions","allowBooking","summary","startDateTimeLocal","endDateTimeLocal","presenterIdentifiers","labelIdentifiers","locationIdentifier","liveVideoUrl","recordedVideoUrl","restrictToAttendeeCategories","capacity","isUnlimited","price","currency","amount","remainingPlaces","isWaitingListAvailable","attendees","bookedTicketIdentifier","attendeeCategoryIdentifier","bookedDays","bookedSessions","waitingListSessions","bookedTickets","ticketIdentifier","bookedSubTickets","tickets","ticketType","displayOrder","alert","message","typeToColorMap","selectSession","modalPrimary","modalSecondary","EvfButton","children","disabled","buttonType","onClick","Button","color","data-button-type","EvfSessions","props","rga4","useRGA4","useState","modalParentProps","SessionsModal","useMemo","parentProps","modalHeader","modalBody","modalFooter","toggle","isOpen","Modal","ModalHeader","ModalBody","ModalFooter","bookingRequest","useCallback","sessionId","ids","event","session","console","log","Promise","resolve","setTimeout","onBookingRequest","waitingRequest","onWaitingRequest","showVersion","onSessionBookingRequest","onSessionWaitingListRequest","sessionAgendaProps","testData","ButtonComponent","ModalComponent","ga4Config","debug_mode","App","code","config","Boolean","window","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"itdA6EAA,26E,gBAAAA,2gK,gBAAAA,uM,gBAAAA,0R,gBAAAA,m5J,iBAAAA,i0NC7DAC,GAAKA,UAAYA,GAAjBA,UCVA,u+CAAAC,EAAA,0HAAAA,EAAA,GAAAA,IAAA,6GAAAA,GAAA,mBAAAA,IAAA,IAAAA,EAAA,gBAAAA,EAAA,eAAAA,GAAA,GAAAA,EAAA,kBAAAA,GAAA,0HAAAA,EAAA,qCAAAA,EAAA,qxECcAC,GAAUA,UAAYA,GAAtBA,ueCMA,4BAGA,SAASC,GAAcC,EAAMC,GAA7B,8VAuBAC,GAAIA,IAAMA,GAAVA,6BAGAA,GAAIA,OAASA,GAAbA,iCAGAA,GAAIA,SAAWA,GAAfA,yBAGAA,GAAIA,KAAOA,GAAXA,+BAGAA,GAAIA,QAAUA,GAAdA,2CAGAA,GAAIA,cAAgBA,GAApBA,mBAGAA,GAAIA,EAAIA,GAARA,2BAGAA,GAAIA,MAAQA,GAAZA,yBAGAA,GAAIA,KAAOA,GAAXA,6CAGAA,GAAIA,eAAiBA,GAArBA,6BAGAA,GAAIA,OAASA,GAAbA,yBAGAA,GAAIA,KAAOA,GAAXA,yBAGAA,GAAIA,KAAOA,GAAXA,+BAGAA,GAAIA,QAAUA,GAAdA,+BAGAA,GAAIA,QAAUA,GAAdA,iCAGAA,GAAIA,SAAWA,GAAfA,6CAGAA,GAAIA,eAAiBA,GAArBA,yBAGAA,GAAIA,KAAOA,GAAXA,yBAGAA,GAAIA,KAAOA,GAAXA,6BAGAA,GAAIA,OAASA,GAAbA,yBAGAA,GAAIA,KAAOA,GAAXA,iCAGAA,GAAIA,SAAWA,GAAfA,2BAGAA,GAAIA,MAAQA,GAAZA,uBAGAA,GAAIA,IAAMA,GC7GV,soNCVA,+3IC8GAC,GAASA,UAAYA,GAArBA,iBCvGA,kqMCQAC,GAAWA,UAAYA,GAAvBA,+7JCCA,049BCDA,+nDAiIAC,GAAWA,KAAOA,GAAlBA,qYCjIA,kpCCIA,ykECbA,wsH,kDAAA,kH,2DAAA,iL,sBAAA,iF,eAAA,y/G,WAAA,wM,0CAAA,uB,qBAAA,0B,qBAAA,sC,KAAA,G,WAAA,yK,0CAAA,4B,qBAAA,6B,KCJA,+U,WAAA,wM,0CAAA,kC,qBAAA,0C,qBAAA,4C,KCFA,6J,WAAA,wM,0CAAA,0C,qBAAA,4C,qBAAA,sC,KCCA,s4DCQA,6GC+CA,O,kDApDA,4L,0CAAA,0c,qBAAA,uc,qBAAA,yc,cDkBA,0N,0CAAA,yH,qBAAA,4J,qBAAA,0C,qBAAA,yO,qBAAA,yO,qBAAA,iP,OEpBA,6nDCIA,2vDCsCAC,GAAUA,UAAYA,CAAtBA,k2BC/BAC,GAAOA,IAAMA,WAAbA,UACAA,GAAOA,MAAQA,WAAfA,UACAA,GAAOA,MAAQA,WAAfA,UACAA,GAAOA,KAAOA,WAAdA,UACAA,GAAOA,IAAMA,WAAbA,UACAA,GAAOA,KAAOA,WAAdA,UACAA,GAAOA,MAAQA,WAAfA,q2CCrBA,8mR,WAAA,mW,0CAAA,iC,qBAAA,6B,qBAAA,4B,qBAAA,0B,qBAAA,8B,qBAAA,6B,qBAAA,qC,qBAAA,8B,KAAA,gCAAAC,EAAA,EAAAA,EAAA,mBAAAA,GAAA,IAAAA,EAAA,MAAAA,GAAA,sSCEA,k+ECFA,IAAIC,GAAuB,CAA3B,+gCCCA,IAAI,GAAJ,6tCC0CA,sEARA,6LCjCA,IAAI,GAAJ,2RCyFA,SAAuBC,EAAaC,GAApC,qgIAAS,GAAT,0DAAS,GAAT,kFC7EA,mrDCPA,wVDOA,wFCPA,+jCDOA,wECPA,kmCDOA,iDCPA,q/FDOA,yDCPA,uFDOA,kDCPA,6TDOA,oDCPA,2FDOA,oDCPA,8BDOA,yGCPA,23BAgzBA,SAASC,GAAoBC,EAAQC,GAArC,+HAcA,SAASC,GAAkCF,EAAQC,GAAnD,0DASA,SAASE,GAAeH,EAAQC,GAAhC,qFC90BA,SAASG,GAAkBC,EAASC,GAApC,oLAyBA,SAASC,GAAkBF,EAASC,GAApC,oLAkEA,IAAIE,GAAiB,CAArB,OAzCA,0XAAS,GAAT,qCAAS,GAAT,qCAAS,GAAT,8pBC7BA,IAAIC,GAAyB,wDAA7B,00CAuZA,SAASC,GAAmBC,GAA5B,usBAAS,GAAT,qWCzaA,izLCUA,4qMCJA,uICCA,mwDCFA,m1ECLA,22DCWA,43CCPA,ICLA,GDKA,0qCCLA,G,WAAA,4J,0CAAA,+B,qBAAA,gO,qBAAA,oO,qBAAA,oF,KAAA,0qB,WAAA,wM,0CAAA,4B,qBAAA,6B,qBAAA,8B,KCEA,qwECQA,0sBA6BAC,GAAgBA,UAAYA,CAA5BA,sCAUA,i1MCxCA,iXCCA,g9CDDA,8sBCCA,s1ECMA,iwCCZA,40FC8DAC,GAAYA,UAAYA,CAAxBA,oD,IAAAA,G,WAAAA,wM,0CAAAA,gC,qBAAAA,0B,qBAAAA,iC,KAAAA,iXClEA,03BCEA,2ZCCA,sYCIA,wxCpBmaA,+sBoBnaA,qrBCPA,mvBCMA,sgBCYA,m1LCbA,mkICqCAC,GAAUA,UAAYA,CAAtBA,0HCpCA,oZCEA,2fCFA,qoCDEA,m8BCFA,6QFAA,6tBEAA,66JCCA,ysExCYApB,uOwCZA,8lBCCA,2cCNA,wyECmBAqB,GAASA,UAAYA,CAArBA,oCCvBA,yzBAiDAC,GAAYA,UAAYA,CAAxBA,oECjDA,skDAAArB,EAAA,EAAAA,EAAA,mBAAAA,GAAA,IAAAA,EAAA,MAAAA,GAAA,27DCsFAsB,GAAeA,UAAYA,CAA3BA,4zBX/EA,glBW+EAA,qnFCqEAC,GAAgBA,UAAYA,CAA5BA,4GC3JA,21BAsEAC,GAASA,UAAYA,CAArBA,qCCtEA,8HAAAxB,EAAA,EAAAA,EAAA,mBAAAA,GAAA,IAAAA,EAAA,MAAAA,GAAA,sSAYA,87CCDA,uDDCA,8WCDA,kmBA0CAyB,GAAgBA,UAAYA,CAA5BA,6DCrDA,gIAAAzB,EAAA,EAAAA,EAAA,mBAAAA,GAAA,IAAAA,EAAA,MAAAA,GAAA,62CA6DA0B,GAAUA,UAAYA,GC1DtB,s6BCWA,kiHCGA,uKnBVA,q6BmBUA,wgGbPA,krCaOA,09BCjBA,SAASC,GAAWC,GAApB,wBAKA,SAASC,GAAUC,EAAMC,GAAzB,6DCwCA,SAASC,GAAWC,GAApB,6IAUA,SAASC,GAAeC,EAAMC,EAAOC,EAAKC,GAA1C,4BAlCA,6sBDPA,wjBCyvBA,SAASC,GAAMC,EAAGC,EAAYC,GAA9B,kCAQA,o0DC5wBA,o1G,6JCAaC,EACX,syKCFa,GACbC,kBAAmB,CACjBC,WAAY,aACZC,WAAY,MAEdC,WAAY,CACV,CACEC,UAAW,EACXC,KAAM,aACNC,QAAS,4BAEX,CACEF,UAAW,EACXC,KAAM,aACNC,QAAS,qBAEX,CACEF,UAAW,EACXC,KAAM,aACNC,QAAS,iBAEX,CACEF,UAAW,EACXC,KAAM,aACNC,QAAS,UAGbC,SAAU,CACRC,sBAAsB,EACtBC,wBAAwB,GAE1BC,WAAY,CACV,CACEC,WAAY,IACZC,MAAO,KACPC,UAAW,QACXC,SAAU,UACVC,MAAO,qBACPC,SAAU,kBACVC,QAAS,kBACTC,cACE,6LACFC,UACE,icAEJ,CACER,WAAY,IACZC,MAAO,KACPC,UAAW,UACXC,SAAU,WACVC,MAAO,sBACPC,SAAU,oBACVC,QAAS,4BACTE,UAAW,IAEb,CACER,WAAY,IACZC,MAAO,MACPC,UAAW,SACXC,SAAU,WACVC,MAAO,qBACPC,SAAU,kBACVC,QAAS,kBACTC,cACE,6LACFC,UAAWpB,GAEb,CACEY,WAAY,IACZE,UAAW,QACXC,SAAU,OACVC,MAAO,mBACPC,SAAU,UACVC,QAAS,aACTE,UAAWpB,IAGfqB,OAAQ,CACN,CACET,WAAY,IACZ/D,KAAM,YACNyE,UAAW,uBAEb,CACEV,WAAY,IACZ/D,KAAM,WACNyE,UAAW,uBAEb,CACEV,WAAY,IACZ/D,KAAM,UACNyE,UAAW,uBAEb,CACEV,WAAY,IACZ/D,KAAM,YACNyE,UAAW,uBAEb,CACEV,WAAY,IACZ/D,KAAM,mBACNyE,UAAW,uBAEb,CACEV,WAAY,IACZ/D,KAAM,SACNyE,UAAW,wBAGfC,UAAW,CACT,CACEX,WAAY,IACZ/D,KAAM,cAER,CACE+D,WAAY,IACZ/D,KAAM,cAGV2E,SAAU,CACR,CACEC,cAAc,EACdb,WAAY,IACZ/D,KACE,8IACF6E,QACE,+3BACFrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,CAAE,IAAK,KAC7BC,iBAAkB,CAAE,IAAK,KACzBC,mBAAoB,IACpBC,aAAc,iCACdC,iBAAkB,8CAClBC,6BAA8B,GAC9BC,SAAU,CACRC,aAAa,GAEfC,MAAO,CACLC,SAAU,MACVC,OAAQ,MAGZ,CACEd,cAAc,EACdb,WAAY,IACZ/D,KAAM,gEACN6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,GACtBC,iBAAkB,CAAC,KACnBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,GAC9BC,SAAU,CACRC,aAAa,IAGjB,CACEX,cAAc,EACdb,WAAY,IACZ/D,KAAM,sCACN6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,GACtBC,iBAAkB,CAAE,IAAK,KACzBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,CAAE,IAAK,KACrCC,SAAU,CACRC,aAAa,EACbI,gBAAiB,EACjBC,wBAAwB,IAG5B,CACEhB,cAAc,EACdb,WAAY,KACZ/D,KAAM,sDACN6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,GACtBC,iBAAkB,GAClBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,CAAE,IAAK,KACrCC,SAAU,CACRC,aAAa,EACbI,gBAAiB,EACjBC,wBAAwB,IAG5B,CACEhB,cAAc,EACdb,WAAY,IACZ/D,KAAM,sDACN6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,CAAC,KACvBC,iBAAkB,GAClBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,GAC9BC,SAAU,CACRC,aAAa,EACbI,gBAAiB,EACjBC,wBAAwB,IAG5B,CACEhB,cAAc,EACdb,WAAY,IACZ/D,KAAM,0CACN6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,GACtBC,iBAAkB,GAClBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,GAC9BC,SAAU,CACRC,aAAa,EACbI,gBAAiB,EACjBC,wBAAwB,IAG5B,CACEhB,cAAc,EACdb,WAAY,IACZ/D,KAAM,mDACN6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,GACtBC,iBAAkB,GAClBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,CAAC,KAC/BC,SAAU,CACRC,aAAa,IAGjB,CACEX,cAAc,EACdb,WAAY,IACZ/D,KAAM,0BACN6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,GACtBC,iBAAkB,GAClBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,CAAC,KAC/BC,SAAU,CACRC,aAAa,EACbI,gBAAiB,EACjBC,wBAAwB,IAG5B,CACEhB,cAAc,EACdb,WAAY,IACZ/D,KACE,qGACF6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,GACtBC,iBAAkB,CAAC,KACnBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,CAAC,KAC/BC,SAAU,CACRC,aAAa,IAGjB,CACEX,cAAc,EACdb,WAAY,IACZ/D,KAAM,0BACN6E,QAAS,GACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,GACtBC,iBAAkB,CAAE,IAAK,KACzBC,mBAAoB,IACpBC,aAAc,GACdC,iBAAkB,GAClBC,6BAA8B,CAAC,KAC/BC,SAAU,CACRC,aAAa,IAGjB,CACEX,cAAc,EACdb,WAAY,KACZ/D,KAAM,qBACN6E,QAAS,oDACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,CAAE,IAAK,KAC7BC,iBAAkB,CAAE,IAAK,KACzBC,mBAAoB,IACpBC,aAAc,iCACdC,iBAAkB,8CAClBC,6BAA8B,GAC9BC,SAAU,CACRC,aAAa,EACbK,wBAAwB,EACxBD,gBAAiB,GAEnBH,MAAO,CACLC,SAAU,MACVC,OAAQ,MAGZ,CACEd,cAAc,EACdb,WAAY,KACZ/D,KAAM,wBACN6E,QAAS,oDACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,CAAE,IAAK,KAC7BC,iBAAkB,CAAE,IAAK,KACzBC,mBAAoB,IACpBC,aAAc,iCACdC,iBAAkB,8CAClBC,6BAA8B,GAC9BC,SAAU,CACRC,aAAa,GAEfC,MAAO,CACLC,SAAU,MACVC,OAAQ,MAGZ,CACEd,cAAc,EACdb,WAAY,KACZ/D,KAAM,wBACN6E,QAAS,oDACTrB,UAAW,EACXsB,mBAAoB,sBACpBC,iBAAkB,sBAClBC,qBAAsB,CAAE,IAAK,KAC7BC,iBAAkB,CAAE,IAAK,KACzBC,mBAAoB,IACpBC,aAAc,iCACdC,iBAAkB,8CAClBC,6BAA8B,GAC9BC,SAAU,CACRC,aAAa,EACbI,gBAAiB,IACjBC,wBAAwB,GAE1BJ,MAAO,CACLC,SAAU,MACVC,OAAQ,OAIdG,UAAW,CACT,CACEC,uBAAwB,IACxB9F,KAAM,iBACN+F,2BAA4B,IAC5BC,WAAY,CAAE,EAAG,GACjBC,eAAgB,IAElB,CACEH,uBAAwB,IACxB9F,KAAM,mCACN+F,2BAA4B,IAC5BC,WAAY,CAAC,GACbC,eAAgB,GAChBC,oBAAqB,CAAC,MAExB,CACEJ,uBAAwB,IACxB9F,KAAM,gBACN+F,2BAA4B,IAC5BC,WAAY,CAAE,EAAG,GACjBC,eAAgB,CAAE,IAAK,IAAK,MAE9B,CACEH,uBAAwB,IACxB9F,KAAM,cACN+F,2BAA4B,IAC5BC,WAAY,CAAE,GACdC,eAAgB,CAAE,OAEpB,CACEH,uBAAwB,IACxB9F,KAAM,cACN+F,2BAA4B,IAC5BC,WAAY,CAAC,GACbC,eAAgB,IAElB,CACEH,uBAAwB,IACxB9F,KAAM,aACN+F,2BAA4B,IAC5BC,WAAY,CAAC,GACbC,eAAgB,IAElB,CACEH,uBAAwB,IACxBC,2BAA4B,IAC5BC,WAAY,CAAE,EAAG,GACjBC,eAAgB,CAAE,IAAK,MAEzB,CACEH,uBAAwB,IACxBC,2BAA4B,IAC5BC,WAAY,CAAE,EAAG,GACjBC,eAAgB,CAAE,IAAK,OAG3BE,cAAe,CACb,CAAEpC,WAAY,IAAKqC,iBAAkB,MACrC,CAAErC,WAAY,IAAKqC,iBAAkB,MACrC,CAAErC,WAAY,IAAKqC,iBAAkB,MACrC,CAAErC,WAAY,IAAKqC,iBAAkB,MACrC,CAAErC,WAAY,IAAKqC,iBAAkB,MACrC,CAAErC,WAAY,IAAKqC,iBAAkB,MACrC,CACErC,WAAY,IACZqC,iBAAkB,KAClBC,iBAAkB,CAChB,CAAEtC,WAAY,IAAKqC,iBAAkB,MACrC,CAAErC,WAAY,IAAKqC,iBAAkB,SAI3CE,QAAS,CACP,CACEC,WAAY,SACZxC,WAAY,KACZ/D,KAAM,mBACNwG,aAAc,GAEhB,CACED,WAAY,SACZxC,WAAY,KACZ/D,KAAM,MACNwG,aAAc,GAEhB,CACED,WAAY,QACZxC,WAAY,KACZ/D,KAAM,QACNwG,aAAc,GAEhB,CACED,WAAY,QACZxC,WAAY,KACZ/D,KAAM,gBACNwG,aAAc,IAGlBC,MAAO,CACLC,QAAS,GACT1C,MAAO,GACP/D,KAAM,U,iBCheJ0G,EAAiB,CACrBC,cAAe,OACfC,aAAc,UACdC,eAAgB,aAaLC,EAAY,SAAC,GAOnB,IANLC,EAMI,EANJA,SACAC,EAKI,EALJA,SACAC,EAII,EAJJA,WACAzC,EAGI,EAHJA,UACA0C,EAEI,EAFJA,QAEI,0EACJ,OACE,kBAACC,EAAA,EAAD,CACE3C,UAAWA,EACX0C,QAASA,EACTF,SAAUA,EACVI,MAAOV,EAAeO,GACtBI,mBAAkBJ,GAEhBF,I,oCC3BKO,EAAc,SAAAC,GACzB,IAAMC,EAAOC,cAEb,EAA2BC,mBAAS,CAAElD,UAAW,cAA1CmD,EAAP,oBAEMC,EAAgBC,mBAAQ,WAC5B,OCR2BC,EDQJH,ECLlB,YAA8D,IAA3DI,EAA0D,EAA1DA,YAAaC,EAA6C,EAA7CA,UAAWC,EAAkC,EAAlCA,YAAaC,EAAqB,EAArBA,OAAQC,EAAa,EAAbA,OACrD,OAME,kBAACC,EAAA,EAAD,iBACMN,EADN,CAEEK,OAAQA,EACRD,OAAQA,IAENH,GAAe,kBAACM,EAAA,EAAD,KAAeN,GAC9BC,GAAa,kBAACM,EAAA,EAAD,KAAaN,GAC1BC,GAAe,kBAACM,EAAA,EAAD,KAAeN,KAjBT,IAAAH,IDS1B,CAACH,IAEEa,EAAiBC,uBAAY,SAACC,EAAWC,GAM7C,OALAnB,EAAKoB,MAAM,CACT7I,KAAM,kBACN8I,QAASH,EACTC,IAAKA,IAvBc,SAACD,EAAWC,GAEnC,OADAG,QAAQC,IAAI,+BAAgCL,EAAW,mBAAoBC,GACpE,IAAIK,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAAS,QAuBzCE,CAAiBT,EAAWC,KAClC,CAACnB,IAEE4B,EAAiBX,uBAAY,SAACC,EAAWC,GAM7C,OALAnB,EAAKoB,MAAM,CACT7I,KAAM,kBACN8I,QAASH,EACTC,IAAKA,IA3Bc,SAACD,EAAWC,GAEnC,OADAG,QAAQC,IAAI,+BAAgCL,EAAW,mBAAoBC,GACpE,IAAIK,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAAS,QA2BzCI,CAAiBX,EAAWC,KAClC,CAACnB,IAEJ,OAAO,kBAAC,IAAD,CACL8B,aAAa,EACbC,wBAAyBf,EACzBgB,4BAA6BJ,EAC7BK,mBAAoBC,EACpBC,gBAAiB7C,EACjB8C,eAAgBhC,KE5CdiC,G,OAAY,CAAEC,YAAY,IAUjBC,EARH,WACV,OACE,kBAAC,IAAD,CAAcC,KAAM,eAAgBC,OAAQJ,GAC1C,kBAAC,EAAD,QCCcK,QACW,cAA7BC,OAAO3H,SAAS4H,UAEe,UAA7BD,OAAO3H,SAAS4H,UAEhBD,OAAO3H,SAAS4H,SAASC,MACvB,2DCbNC,IAASC,OACP,kBAAC,EAAD,MACAC,SAASC,eAAe,SD4HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLnC,QAAQmC,MAAMA,EAAMxE,c","file":"static/js/main.49b42300.chunk.js","sourcesContent":["import { deepMerge } from '@keg-hub/jsutils'\nimport { colors } from './colors'\n\n/**\n * Holds the default fonts. Can be overwritten by setFonts method\n * @object\n */\nconst fonts = {\n  headings: 'Inter-Regular',\n  default: 'Inter-Regular',\n}\n\n/**\n * Gets the default font from the fonts object\n * @function\n *\n * @return {string} Default font name\n */\nexport const getFontDefault = () => fonts.default\n\n/**\n * Cache for the typography styles\n * @object\n */\nexport let typography = {}\n\n/**\n * Updates the default fonts object with the passed in updated object\n * <br/>Then rebuilds the typography styles with the updated fonts\n * @function\n * @param {Object} updated - Fonts object to be merged with the default fonts object\n *\n * @return {Object} Updated typography object\n */\nexport const setFonts = (updated = {}, rebuild) => {\n  Object.assign(fonts, updated)\n  rebuild && buildTypography(rebuild)\n\n  return typography\n}\n\n/**\n * Builds the typography styles based on the current fonts object\n * @function\n * @param {Object} overrides - Values to override the current typography styles\n *\n * @return {Object} Updated typography object\n */\nexport const buildTypography = (overrides = {}) => {\n  typography = deepMerge(\n    {\n      font: {\n        family: {\n          $native: {},\n          $web: {\n            fontFamily: fonts.default,\n          },\n        },\n      },\n      headings: {\n        fontFamily: fonts.headings,\n      },\n      default: {\n        color: colors.black,\n        fontFamily: fonts.default,\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n        fontSize: 16,\n        lineHeight: 22,\n      },\n    },\n    overrides\n  )\n\n  return typography\n}\n\nbuildTypography()\n","import { View as KegView } from './view.native'\nimport { StyleInjector } from '@keg-hub/re-theme/styleInjector'\n\n/**\n * View\n * @summary Default view component that wraps the React Native View component. All props are optional\n *\n * @param {Object} props - see View PropTypes\n * @property {String} props.className - Value to set the className to (web platform only)\n *\n */\nexport const View = StyleInjector(KegView, {\n  displayName: 'View',\n  className: 'keg-view',\n})\n\nView.propTypes = KegView.propTypes\n","import { useMemo } from 'react'\n\n/**\n * All possible heading size options\n * @array\n */\nconst headings = [ 'h1', 'h2', 'h3', 'h4', 'h5', 'h6' ]\n\n/**\n * Custom hook to memoize the accessibilityRole of a text component\n * @function\n * @param {string} element - Name of the text element to build the accessibilityRole props for\n * @param {string} accessibilityRole - Accessibility Role for the element\n *\n * @returns {Object} - Built accessibilityRole props for the text component\n */\nexport const useTextAccessibility = (element, accessibilityRole) => {\n  return useMemo(() => {\n    const type = accessibilityRole\n      ? accessibilityRole\n      : headings.includes(element)\n        ? 'header'\n        : element\n\n    return {\n      accessibilityRole: type,\n      ...(type === 'header' && { ['aria-level']: element[1] }),\n    }\n  }, [ element, accessibilityRole ])\n}\n","import { Touchable as KegTouchable } from './touchable.native'\nimport { StyleInjector } from '@keg-hub/re-theme/styleInjector'\n\n/**\n * Touchable\n * @summary Touchable component that allows interactions based on touch. All props are optional\n *\n * @param {Object} props - see View PropTypes\n * @property {String} props.className - Value to set the className to (web platform only)\n *\n */\nexport const Touchable = StyleInjector(KegTouchable, {\n  displayName: 'Touchable',\n  className: 'keg-touchable',\n  // Important rules should include the prefixed version\n  // Because important rules are checked after going through the prefixer\n  // Important rules have `!important` added to them to allow overwriting the style attribute\n  important: [ 'transitionDuration', 'WebkitTransitionDuration' ],\n})\n\nTouchable.propTypes = KegTouchable.propTypes\n","/**\n * Copyright (c) 2017 Chris Baker <mail.chris.baker@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\nimport * as React from \"react\";\nimport * as ReactNativeWeb from \"react-native-web\";\nimport PropTypes from \"prop-types\";\n\nconst createReactElement =\n  ReactNativeWeb.unstable_createElement || React.createElement;\n\nfunction createElement(name, type) {\n  class CreateElement extends React.Component {\n    render() {\n      return createReactElement(type, this.props, this.props.children);\n    }\n  }\n\n  CreateElement.displayName = name;\n\n  CreateElement.propTypes = {\n    children: PropTypes.node,\n  };\n\n  CreateElement.defaultProps = {\n    children: undefined,\n  };\n\n  return CreateElement;\n}\n\nexport const Svg = createElement(\"Svg\", \"svg\");\n\nexport default Svg;\nSvg.Svg = Svg; // stay consistent with the old require based api\n\nexport const Circle = createElement(\"Circle\", \"circle\");\nSvg.Circle = Circle;\n\nexport const ClipPath = createElement(\"ClipPath\", \"clipPath\");\nSvg.ClipPath = ClipPath;\n\nexport const Defs = createElement(\"Defs\", \"defs\");\nSvg.Defs = Defs;\n\nexport const Ellipse = createElement(\"Ellipse\", \"ellipse\");\nSvg.Ellipse = Ellipse;\n\nexport const ForeignObject = createElement(\"ForeignObject\", \"foreignObject\");\nSvg.ForeignObject = ForeignObject;\n\nexport const G = createElement(\"G\", \"g\");\nSvg.G = G;\n\nexport const Image = createElement(\"Image\", \"image\");\nSvg.Image = Image;\n\nexport const Line = createElement(\"Line\", \"line\");\nSvg.Line = Line;\n\nexport const LinearGradient = createElement(\"LinearGradient\", \"linearGradient\");\nSvg.LinearGradient = LinearGradient;\n\nexport const Marker = createElement(\"Marker\", \"marker\");\nSvg.Marker = Marker;\n\nexport const Mask = createElement(\"Mask\", \"mask\");\nSvg.Mask = Mask;\n\nexport const Path = createElement(\"Path\", \"path\");\nSvg.Path = Path;\n\nexport const Pattern = createElement(\"Pattern\", \"pattern\");\nSvg.Pattern = Pattern;\n\nexport const Polygon = createElement(\"Polygon\", \"polygon\");\nSvg.Polygon = Polygon;\n\nexport const Polyline = createElement(\"Polyline\", \"polyline\");\nSvg.Polyline = Polyline;\n\nexport const RadialGradient = createElement(\"RadialGradient\", \"radialGradient\");\nSvg.RadialGradient = RadialGradient;\n\nexport const Rect = createElement(\"Rect\", \"rect\");\nSvg.Rect = Rect;\n\nexport const Stop = createElement(\"Stop\", \"stop\");\nSvg.Stop = Stop;\n\nexport const Symbol = createElement(\"Symbol\", \"symbol\");\nSvg.Symbol = Symbol;\n\nexport const Text = createElement(\"Text\", \"text\");\nSvg.Text = Text;\n\nexport const TextPath = createElement(\"TextPath\", \"textPath\");\nSvg.TextPath = TextPath;\n\nexport const TSpan = createElement(\"TSpan\", \"tspan\");\nSvg.TSpan = TSpan;\n\nexport const Use = createElement(\"Use\", \"use\");\nSvg.Use = Use;\n","import PropTypes from 'prop-types'\nimport React, { useMemo } from 'react'\nimport { get, deepMerge, isArr, noPropObj } from '@keg-hub/jsutils'\nimport Svg, { Path } from 'react-native-svg'\nimport { useTheme } from '@keg-hub/re-theme'\n\n/**\n * Custom hook to check if the size prop is an array, and merge it. Otherwise just returns the style object\n * @param {Object|Array=} style - Style object used to apply custom styles to the component\n *\n * @returns {Object} - Merged style object\n */\nconst useIconStyle = style => {\n  return useMemo(() => {\n    return isArr(style) ? deepMerge(...style) : style\n  }, [style])\n}\n\n/**\n * Custom hook to find the size from the props and styles\n * @param {string=} size - Size of the Svg Component\n * @param {Object=} style - Style object used to apply custom styles to the component\n * @param {Object=} theme - Global theme object\n *\n * @returns {Object} - Contains the height and width props for the Svg element\n */\nconst useSize = (size, width, height, style, theme) => {\n  return useMemo(() => {\n    const iconSize = size || get(style, 'fontSize')\n    const themeSize = get(theme, 'typography.default.fontSize', 15) * 2\n    return {\n      height: height || iconSize || get(style, 'height', themeSize),\n      width: width || iconSize || get(style, 'width', themeSize),\n    }\n  }, [ size, width, height, style ])\n}\n\n/**\n * Custom hook to find the fill color from the props and styles\n * @param {string=} fill - Fill color of the path element\n * @param {string=} stroke - Color of the stroke for the path element\n * @param {string=} color - Color of the Svg component\n * @param {string} border - Used as the stroke color when no stroke prop is passed\n * @param {Object=} style - Style object used to apply custom styles to the component\n * @param {Object=} theme - Global theme object\n *\n * @returns {Object} - Contains the stroke and fill props for the path element\n */\nconst useColor = (fill, stroke, color, border, style, theme) => {\n  return useMemo(() => {\n    const themeColor = get(theme, 'typography.default.color')\n    return {\n      stroke:\n        stroke || border || style.border || color || style.color || themeColor,\n      fill: fill || color || style.color || stroke,\n    }\n  }, [ fill, stroke, color, border, style ])\n}\n\n/**\n * SvgIcon\n * @param {object} props\n * @param {string} props.border - Used as the stroke color when no stroke prop is passed\n * @param {string=} props.color - Color of the Svg component\n *                              - Used as the stroke color when no stroke prop is passed\n *                              - Used as the fill color when no fill prop is passed\n * @param {string=} props.clipRule - Svg rule for clipping\n * @param {string=} props.delta - Path definition for the Svg Component\n * @param {string=} props.fill - Fill color of the path element\n * @param {string=} props.fillRule - Svg rule for the fill attribute\n * @param {string=} props.size - Size of the Svg Component\n * @param {string=} props.stroke - Color of the stroke for the path element\n * @param {Object=} props.style - Style object used to apply custom styles to the component\n * @param {string=} props.style.border - Used as the stroke color when no stroke or border prop is passed\n * @param {string=} props.style.color - Used as the fill color when no fill or color prop is passed\n * @param {string=} props.svgFill - Fill color of the parent SVG element\n * @param {string=} props.viewBox - View box size of the parent SVG element\n *\n */\nexport const SvgIcon = props => {\n  const {\n    border,\n    color,\n    clipRule,\n    delta,\n    fill,\n    fillRule,\n    height,\n    size,\n    stroke,\n    strokeWidth,\n    strokeLinecap,\n    strokeLinejoin,\n    style = noPropObj,\n    svgFill,\n    viewBox,\n    width,\n    ...attrs\n  } = props\n\n  const iconStyle = useIconStyle(style)\n  const theme = useTheme()\n  const sizeStyle = useSize(size, width, height, iconStyle, theme)\n  const colorStyle = useColor(fill, stroke, color, border, iconStyle, theme)\n\n  return (\n    <Svg\n      {...attrs}\n      fill={svgFill}\n      viewBox={viewBox}\n      style={[ iconStyle, sizeStyle ]}\n    >\n      <Path\n        clipRule={clipRule}\n        d={delta}\n        fill={colorStyle.fill}\n        fillRule={fillRule}\n        stroke={colorStyle.stroke}\n        strokeWidth={strokeWidth}\n        strokeLinecap={strokeLinecap}\n        strokeLinejoin={strokeLinejoin}\n      />\n    </Svg>\n  )\n}\n\nSvgIcon.propTypes = {\n  border: PropTypes.string,\n  color: PropTypes.string,\n  clipRule: PropTypes.string,\n  delta: PropTypes.string,\n  fill: PropTypes.string,\n  fillRule: PropTypes.string,\n  size: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),\n  stroke: PropTypes.string,\n  style: PropTypes.oneOfType([ PropTypes.object, PropTypes.array ]),\n  svgFill: PropTypes.string,\n  viewBox: PropTypes.string,\n}\n","import React from 'react'\nimport { KegText } from 'KegText'\nconst Paragraph = KegText('paragraph')\n\nexport const P = props => {\n  return (\n    <>\n      <Paragraph {...props} />\n      { '\\n' }\n    </>\n  )\n}\n","import { View } from 'KegView'\nimport { Check } from '../../../assets/icons/check'\nimport React, { useMemo, forwardRef } from 'react'\nimport { CheckboxWrapper } from './checkbox.wrapper'\nimport { noPropObj } from '@keg-hub/jsutils'\nimport { StyleInjector } from '@keg-hub/re-theme/styleInjector'\nimport { Input as KegInput } from '../../internal/input.web'\n\n// Styles are defined here so that they are enforced\n// Due to how the checkbox is designed, these styles should not be changed\n// Which is why they are not defined within the theme\nconst checkBoxStyles = {\n  icon: {\n    position: 'relative',\n    zIndex: 1,\n    height: 14,\n    width: 14,\n    top: 0,\n    left: 3,\n    flex: 1,\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  input: {\n    position: 'absolute',\n    zIndex: 2,\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    margin: 0,\n    opacity: 0,\n    cursor: 'pointer',\n  },\n}\n\n/**\n * Wrap the internal component with the Styles Injector Hoc\n * <br/>This allows us to add the styles as css classes\n */\nconst Input = StyleInjector(KegInput, {\n  displayName: 'Checkbox',\n  className: 'keg-checkbox',\n})\n\nconst Element = React.forwardRef((props, ref) => {\n  const {\n    className,\n    elProps,\n    styles = noPropObj,\n    CheckIcon = Check,\n    checked,\n    ...attributes\n  } = props\n\n  const checkStyle = useMemo(() => {\n    return {\n      ...checkBoxStyles.icon,\n      ...styles.indicator,\n    }\n  }, [ checkBoxStyles, styles ])\n\n  const inputStyle = useMemo(\n    () => ({\n      ...styles.input,\n      ...checkBoxStyles.input,\n    }),\n    [ checkBoxStyles, styles ]\n  )\n\n  return (\n    <View\n      style={styles.main}\n      className={className}\n    >\n      <View\n        className='keg-checkbox-area'\n        style={styles.area}\n      />\n\n      { checked && (\n        <CheckIcon\n          className='keg-checkbox-icon'\n          style={checkStyle}\n        />\n      ) }\n\n      <Input\n        className='keg-checkbox'\n        {...elProps}\n        {...attributes}\n        role='checkbox'\n        checked={checked}\n        type='checkbox'\n        ref={ref}\n        style={inputStyle}\n      />\n    </View>\n  )\n})\n\nexport const Checkbox = forwardRef((props, ref) => (\n  <CheckboxWrapper\n    {...props}\n    elType={'checkbox'}\n    Element={Element}\n    isWeb={true}\n    ref={ref}\n  />\n))\n\nCheckbox.propTypes = { ...CheckboxWrapper.propTypes }\n","import React, { useRef, useMemo, useCallback } from 'react'\nimport { handleRefUpdate } from '../utils/helpers/handleRefUpdate'\n\n/**\n * Returns the dynamic props object for the child\n * @param {Object<string, RefObject>} childRefs - the map of child refs\n * @param {ReactElement} child - the child component\n * @param {number} index - the index the child is rendered at (only used if child doesn't have a `key` defined)\n */\nconst buildPropsForChild = (childRefs, child, index) => {\n  // the ref-setter for each child will make use of that child's key identifier,\n  // or the index if the key is not defined\n  const key = child?.key || index || child\n  const existingRef = child?.ref\n  return {\n    key,\n    ref: childRef => {\n      handleRefUpdate(existingRef, childRef)\n      childRefs.current[key] = childRef\n    },\n  }\n}\n\n/**\n * Returns a memoized function for cloning a child react element\n * @param {RefObject<Object>} childRefs - the ref to the object of child refs\n * @return {Function} - the fn to clone a child\n */\nconst useCloneChildCallback = childRefs =>\n  useCallback(\n    (child, index = 0) => {\n      const props = buildPropsForChild(childRefs, child, index)\n      return React.isValidElement(child)\n        ? React.cloneElement(child, props)\n        : child\n    },\n    [childRefs]\n  )\n\n/**\n * If `enable` is true, returns a cloned array of the children, each with the\n * ref props set. Otherwise, returns the children unmodified. If the refs props were used,\n * the child refs will be accessible in a ref object in the return tuple. Also handles\n * merging any existing ref props the consumer defined.\n *\n * Notes:\n *  - it's assumed that the children\n * @param {*} children\n * @param {boolean?} enable - whether to actually clone the children with ref props or not. Defaults to true. We use this because hooks should not be called conditionally.\n * @return {Array<children, RefObject<Object<string, RefObject>>>} - an array for destructuring:\n *  [ children, childRefs ]\n * @example\n * const [ updatedChildren, childRefs ] = useChildrenWithRefs(children)\n * const doSomethingWithChildRefs = () => Object.values(childRefs.current)\n *  .map(ref => doSomething(ref.current))\n * return (\n *  <>\n *    <Button onPress={doSomethingWithChildRefs} />\n *    { updatedChildren }\n *  </>\n * )\n */\nexport const useChildrenWithRefs = (children, enable = true) => {\n  // Store a map of child keys mapped to their refs.\n  // The value is an object, not an array, because using an array\n  // could quickly fill up with duplicate refs\n  const childRefs = useRef({})\n\n  // function to clone a child with the correct props\n  const cloneChild = useCloneChildCallback(childRefs)\n\n  const updatedChildren = useMemo(() => {\n    // if enabled, clone the children, otherwise just return them\n    return enable\n      ? React.Children.count(children) > 1\n        ? children.map(cloneChild)\n        : cloneChild(children)\n      : children\n  }, [ enable, children ])\n\n  return [ updatedChildren, childRefs ]\n}\n","import { ScrollView as KegScrollView } from './scrollView.native'\nimport { StyleInjector } from '@keg-hub/re-theme/styleInjector'\n\n/**\n * ScrollView\n * @summary Default view component that wraps the React Native ScrollView component. All props are optional\n *\n * @param {Object} props - see ScrollView PropTypes\n * @property {String} props.className - Value to set the className to (web platform only)\n * @property {String} props.innerClassName - Value to set the innerClassName to (web platform only)\n *\n */\nexport const ScrollView = StyleInjector(KegScrollView, {\n  displayName: 'Scroll-View',\n  className: 'keg-scrollview',\n})\n\nScrollView.propTypes = KegScrollView.propTypes\n","import { View } from '../view'\nimport PropTypes from 'prop-types'\nimport { get } from '@keg-hub/jsutils'\nimport { useThemePath } from '../../hooks'\nimport { noOpObj } from '@keg-hub/jsutils'\nimport { Animated } from 'react-native'\nimport { useClassName } from 'KegClassName'\nimport React, { useState, useLayoutEffect, useCallback, useRef } from 'react'\nimport { isValidComponent } from '../../utils/validate/isValidComponent'\n/**\n * Checks if the animation should NOT run\n * @param {boolean} toggled - Current state of the Drawer toggled open\n * @param {number} current - Current height of the Drawer / animated.value\n * @param {number} contentMaxHeight\n * @param {number} collapsedHeight\n *\n * @returns {boolean} - If the animation should NOT run\n */\nconst noAnimate = (toggled, current, collapsedHeight, contentMaxHeight) =>\n  (!toggled && current === collapsedHeight) ||\n  (toggled && current === contentMaxHeight)\n\n/**\n * Drawer\n * @param {Object} props - props passed from parent component\n * @param {Function|Component} props.children - Child components placed inside the drawer\n * @param {Number=} props.collapsedHeight - optional. height of the collapsed view\n * @param {string=} props.className\n * @param {Function|Component} props.Element - Child Element of the Drawer. Overrides the default children prop\n * @param {string} props.type - Animation type from the Animated API that accepts an animated config\n * @param {Object} props.config - Animation config object passed on to the Animated type method\n * @param {Object} props.styles - Custom styles to applied to the slider\n * @param {boolean} props.toggled - Is the slider toggled open\n * @param {boolean} props.* - All other props passed on to the Element Component prop if it exists\n *\n * @returns {Component} - Drawer Component\n */\nexport const Drawer = props => {\n  const {\n    Element,\n    styles,\n    toggled,\n    className,\n    type = 'timing',\n    config = noOpObj,\n    collapsedHeight = 0,\n    ...childProps\n  } = props\n\n  // Define the default max height as a ref\n  const contentMaxHeight = useRef(null)\n\n  // Define the animated value as a ref\n  const [ animation, setAnimation ] = useState(\n    new Animated.Value(collapsedHeight)\n  )\n\n  // Define a helper to update the total max height of the slider\n  // Gets called from the onLayout callback of the View wrapper\n  const setMaxHeight = useCallback(\n    event => {\n      const maxHeight = event.nativeEvent.layout.height\n      if (contentMaxHeight.current === maxHeight) return\n\n      contentMaxHeight.current = maxHeight\n      toggled && setAnimation(new Animated.Value(maxHeight))\n    },\n    [ contentMaxHeight, toggled, setAnimation ]\n  )\n\n  // Use useLayoutEffect to check if the slider should be animated\n  // Within the hook, toggled flag defines how to update the animated value\n  // To Open: toggled === true === should animate open\n  // To Close: toggled === false === should animate close\n  useLayoutEffect(() => {\n    // Check if we should animate the slider\n    // If the values have not changed, no need to animate\n    if (\n      noAnimate(\n        toggled,\n        animation._value,\n        collapsedHeight,\n        contentMaxHeight.current\n      )\n    )\n      return\n    // Define the from and to values for the animation based on toggled flag\n    const heightChanges = toggled\n      ? { from: collapsedHeight, to: contentMaxHeight.current }\n      : { from: contentMaxHeight.current, to: collapsedHeight }\n\n    // Update the animation value to animate from\n    animation.setValue(heightChanges.from)\n    // Start the animation, from value ==> to value\n    const animationConfig = config\n      ? { ...config, toValue: heightChanges.to }\n      : { toValue: heightChanges.to }\n    Animated[type](animation, animationConfig).start()\n\n    // Add toggled as a dep, so anytime it changes, we run the hook code\n  }, [ toggled, type, config, collapsedHeight ])\n\n  const drawerStyles = useThemePath(`drawer`, styles)\n  const classRef = useClassName('keg-drawer', className)\n\n  return (\n    <Animated.View\n      ref={classRef}\n      style={[ drawerStyles.main, get(styles, 'main'), { maxHeight: animation }]}\n    >\n      <View\n        className='keg-drawer-content'\n        onLayout={setMaxHeight}\n        style={get(styles, 'content')}\n      >\n        { isValidComponent(Element) ? (\n          <Element\n            {...childProps}\n            styles={styles}\n          />\n        ) : (\n          props.children\n        ) }\n      </View>\n    </Animated.View>\n  )\n}\n\nDrawer.propTypes = {\n  className: PropTypes.oneOfType([ PropTypes.array, PropTypes.string ]),\n  config: PropTypes.object,\n  Element: PropTypes.oneOfType([ PropTypes.func, PropTypes.elementType ]),\n  styles: PropTypes.oneOfType([ PropTypes.object, PropTypes.array ]),\n  toggled: PropTypes.bool,\n  type: PropTypes.oneOf([ 'decay', 'spring', 'timing' ]),\n  collapsedHeight: PropTypes.number,\n}\n","import React, { useCallback, useImperativeHandle, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { View } from 'KegView'\nimport { Text } from '../../typography/text'\nimport { Checkbox } from 'KegCheckbox'\nimport { useStyle } from '@keg-hub/re-theme'\nimport { useClassList } from 'KegClassList'\nimport { useChildrenWithRefs } from '../../../hooks/useChildrenWithRefs'\nimport { mapObj, noOp } from '@keg-hub/jsutils'\n\n/**\n * Simple header for CheckGroup, without a checkbox\n * @param {Object} props\n * @param {string} props.title - title of header\n * @param {Object} props.style - style rules to apply to the Text element\n * @param {*} props.* - remaining props are passed to the Text element\n */\nconst SimpleHeader = React.forwardRef((props, ref) => {\n  const { title, className, style, ...rest } = props\n\n  // add no-op handle here just for consistency with other header\n  useImperativeHandle(ref, () => ({ isChecked: undefined, setChecked: noOp }))\n\n  const textStyle = useStyle('form.checkGroup.simpleHeader.main', style)\n  return (\n    <Text\n      className={className}\n      style={textStyle}\n      {...rest}\n    >\n      { title }\n    </Text>\n  )\n})\n\n/**\n * Header for CheckGroup, with a checkbox for select-all functionality\n * @param {Object} props\n * @param {string} props.title - title of header\n * @param {Object} props.style - style rules to apply to the header\n * @param {Function?} props.onPress - handler for checkbox press\n * @param {boolean} props.checked - initial value of header checkbox\n */\nconst CheckboxHeader = React.forwardRef((props, ref) => {\n  const { title, className, style, onPress, checked } = props\n  const headerStyles = useMemo(\n    () => ({\n      main: style,\n      content: {\n        right: {},\n      },\n    }),\n    [style]\n  )\n\n  const onChangeHandler = useCallback((_, val) => onPress?.(val), [onPress])\n\n  return (\n    <Checkbox\n      RightComponent={title}\n      rightClassName={className}\n      styles={headerStyles}\n      checked={checked}\n      onChange={onChangeHandler}\n      ref={ref}\n      close\n    />\n  )\n})\n\n/**\n * A group of checkbox items with a header.\n * Will include a select-all checkbox in the header IF you define the children as a function (@see story examples)\n * @param {Object} props\n * @param {string} props.className - css class name\n * @param {string} props.headerClassName - css class name for header text\n * @param {string} props.title - title of the group\n * @param {boolean?} props.initChecked - initial checked value of the group header box, if you are using it\n * @param {boolean?} props.showHeaderCheckbox - true if you want a group header check box, with select-all functionality\n * @param {boolean?} props.showHeader - true by default. If false, hides the header entirely, only showing children\n * @param {Function?} props.onGroupPress - handler of header checkbox\n * @param {*} props.children - components in the group (@see CheckboxGroup.Item)\n * @param {Object?} props.styles\n * @param {Object?} props.styles.main\n * @param {Object?} props.styles.header\n */\nexport const CheckGroup = React.forwardRef((props, ref) => {\n  const {\n    className,\n    headerClassName,\n    title,\n    children,\n    styles,\n    initChecked = false,\n    onGroupPress,\n    showHeaderCheckbox = false,\n    showHeader = true,\n  } = props\n\n  const groupStyles = useStyle('form.checkGroup', styles)\n\n  // get children updated with ref props, and the refs themselves\n  const [ childrenWithProps, childRefs ] = useChildrenWithRefs(\n    children,\n    showHeaderCheckbox\n  )\n\n  // callback that manages select-all behavior on click of the header checkbox\n  const headerCheckHandler = useCallback(\n    checked => {\n      onGroupPress?.(checked)\n      mapObj(childRefs.current, (_, child) => child?.setChecked?.(checked))\n    },\n    [childRefs]\n  )\n\n  const Header = () =>\n    showHeaderCheckbox ? (\n      <CheckboxHeader\n        className={headerClassName}\n        style={groupStyles?.header}\n        title={title}\n        onPress={showHeaderCheckbox && headerCheckHandler}\n        checked={showHeaderCheckbox ? initChecked : undefined}\n        ref={ref}\n      />\n    ) : (\n      <SimpleHeader\n        className={headerClassName}\n        style={groupStyles?.header}\n        title={title}\n        ref={ref}\n      />\n    )\n\n  return (\n    <View\n      className={useClassList('keg-check-group', className)}\n      style={groupStyles?.main}\n    >\n      { showHeader && <Header /> }\n      { childrenWithProps }\n    </View>\n  )\n})\n\nCheckGroup.Item = Checkbox\n\nCheckGroup.propTypes = {\n  className: PropTypes.oneOfType([ PropTypes.array, PropTypes.string ]),\n  headerClassName: PropTypes.oneOfType([ PropTypes.array, PropTypes.string ]),\n  title: PropTypes.string,\n  initChecked: PropTypes.bool,\n  showHeaderCheckbox: PropTypes.bool,\n  showHeader: PropTypes.bool,\n  onGroupPress: PropTypes.func,\n  styles: PropTypes.oneOfType([ PropTypes.object, PropTypes.array ]),\n}\n","import React from 'react'\nimport { View } from 'KegView'\nimport PropTypes from 'prop-types'\nimport { Select as InternalSelect } from '../../internal/select'\nimport { useThemePath } from '../../../hooks'\nimport { useSelectHandlers } from '../../../hooks/useSelectHandlers'\nimport { getValueFromChildren, getInputValueKey } from '../../../utils'\nimport { useClassName } from 'KegClassName'\nimport { useThemeTypeAsClass } from 'KegTypeAsClass'\nimport { ChevronDown } from '../../../assets/icons'\nimport { Icon } from 'KegIcon'\nimport { StyleInjector } from '@keg-hub/re-theme/styleInjector'\n\n/**\n * Wrap the internal component with the Styles Injector Hoc\n * <br/>This allows us to add the styles as css classes\n */\nconst KegSelect = StyleInjector(InternalSelect, {\n  displayName: 'Select',\n  className: 'keg-select',\n})\n\n/**\n * Gets the key value pair for the select components value\n * @param {*} props - Props passed to the component\n *\n * @returns {Object} - key / value pair for the select component\n */\nconst getValue = props => {\n  const { children, onChange, onValueChange, readOnly, value } = props\n\n  const setValue = getValueFromChildren(value, children)\n  const valKey = getInputValueKey(false, onChange, onValueChange, readOnly)\n\n  return { [valKey]: setValue }\n}\n\n/**\n * Select\n * @summary Default Select component that wraps the Internal Select component with the styles injector. All props are optional\n *\n * @param {Object} props - see KegSelect PropTypes\n * @property {String} props.className - Value to set the className to (web platform only)\n *\n */\nexport const Select = React.forwardRef((props, ref) => {\n  const {\n    className,\n    children,\n    disabled,\n    readOnly,\n    onChange,\n    onValueChange,\n    style,\n    styles,\n    type = 'default',\n    themePath = `form.select.${type}`,\n    value,\n    ...elProps\n  } = props\n\n  const selectStyles = useThemePath(themePath, styles)\n  const selectClasses = useThemeTypeAsClass(\n    themePath || type,\n    'keg-select',\n    className\n  )\n  const classRef = useClassName('keg-select', selectClasses, ref)\n\n  return (\n    <View style={[ selectStyles.main, style ]}>\n      <KegSelect\n        ref={classRef}\n        {...elProps}\n        enabled={!disabled}\n        style={[selectStyles.select]}\n        {...getValue(props)}\n        {...useSelectHandlers({ onChange, onValueChange })}\n      >\n        { children }\n      </KegSelect>\n      <Icon\n        styles={selectStyles.icon}\n        Component={ChevronDown}\n        color={disabled && selectStyles.icon?.disabled?.color}\n      />\n    </View>\n  )\n})\n\nSelect.propTypes = {\n  ...InternalSelect.propTypes,\n  children: PropTypes.oneOfType([\n    PropTypes.object,\n    PropTypes.string,\n    PropTypes.array,\n  ]),\n  disabled: PropTypes.bool,\n  onChange: PropTypes.func,\n  onValueChange: PropTypes.func,\n  ref: PropTypes.object,\n  style: PropTypes.object,\n  type: PropTypes.string,\n  value: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\n}\n","import { View } from 'KegView'\nimport PropTypes from 'prop-types'\nimport { Text } from '../../typography'\nimport { useTheme } from '@keg-hub/re-theme'\nimport React, {\n  useState,\n  useImperativeHandle,\n  useMemo,\n  forwardRef,\n} from 'react'\nimport { useThemeTypeAsClass } from 'KegTypeAsClass'\nimport { useThemePath } from '../../../hooks'\nimport { get, isStr, toBool, checkCall } from '@keg-hub/jsutils'\nimport { getOnChangeHandler, getChecked, renderFromType } from '../../../utils'\nimport { Switch as InternalSwitch } from '../../internal/switch.js'\nimport { StyleInjector } from '@keg-hub/re-theme/styleInjector'\n\n/**\n * Wrap the internal component with the Styles Injector Hoc\n * <br/>This allows us to add the styles as css classes\n */\nconst KegSwitch = StyleInjector(InternalSwitch, {\n  displayName: 'Switch',\n  className: 'keg-switch',\n})\n\n/**\n * Gets the custom Native Switch colors from the passed in styles\n * @param {string} thumbColor - Color of the on/off indicator\n * @param {string} trackColor - Color of the background track\n * @param {Object} styles - { indicator={}, area={} } - passed in switch styles\n *\n * @returns {Object} - Contains the Native color props for the Switch component\n */\nconst getSwitchColors = (\n  thumbColor,\n  trackColor,\n  { indicator = {}, area = {} }\n) => {\n  const indicatorColor = thumbColor || indicator.color\n  const areaColor = trackColor || area.backgroundColor\n  const colors = {\n    ...(indicatorColor && { thumbColor: thumbColor || color }),\n    ...(areaColor && { trackColor: areaColor, onTintColor: areaColor }),\n  }\n\n  return colors\n}\n\n/**\n * Optimizes the check and non-checked styles so they don't have to be rebuilt on each render\n * Checked styles only rebuild when isChecked value has changed\n * @param {boolean} isChecked - Current state of the switch component\n * @param {Object} themeStyles - Styles of the Switch component\n *\n * @returns {Object} - Styles with the correct values based on isChecked state\n */\nconst useCheckedState = (isChecked, themeStyles) => {\n  const theme = useTheme()\n  return useMemo(() => {\n    return theme.get(themeStyles, {\n      content: {\n        area: {\n          ...get(themeStyles, 'content.area.off'),\n          ...(isChecked && get(themeStyles, 'content.area.on')),\n        },\n        indicator: {\n          ...get(themeStyles, 'content.indicator.off'),\n          ...(isChecked && get(themeStyles, 'content.indicator.on')),\n        },\n      },\n    })\n  }, [isChecked])\n}\n\n/**\n * Sets / Updates the value of the checked Component\n * Calls the callback, if it's passed in\n * @param {boolean} isChecked - Current state of the check value\n * @param {function} setChecked - Update the checked state\n * @param {function} onChange - Callback to call when the state changes\n *\n * @returns {function} - The checked state update function\n */\nconst setCheckedValue = (isChecked, setChecked, onChange) => {\n  return event => {\n    setChecked(!isChecked)\n    checkCall(onChange, event, !isChecked)\n  }\n}\n\n/**\n * Side\n * @summary builds the side sections of the Switch\n * @param {Object} props\n * @property {React Component|string|Object|Array} Component  - custom component to display in the section.\n * @property {Object} style - default headerstyle obj for section\n *\n * @returns {Component} - section component\n */\nconst SideComponent = ({ Component, style }) => {\n  return isStr(Component) ? (\n    <Text style={style}>{ Component }</Text>\n  ) : (\n    renderFromType(Component, { style: styles.content })\n  )\n}\n\n/**\n * Finds the children type and returns them in the format needed to render\n * @param {Object|Array|string} props.children - Child components to render\n *\n * @returns {React Component|Object|Array}\n */\nconst ChildrenComponent = ({ children }) => (\n  <>{ renderFromType(children, {}, null) }</>\n)\n\n/**\n * Exposes an imperative api for the consumer of switch\n * @param {RefObject} ref\n * @param {boolean} isChecked\n * @param {Function} setChecked\n */\nconst useSwitchHandle = (ref, isChecked, setChecked) => {\n  return useImperativeHandle(\n    ref,\n    () => ({\n      isChecked,\n      setChecked,\n    }),\n    [ ref, isChecked, setChecked ]\n  )\n}\n\n/**\n * Switch\n * Wraps the Internal KegSwitch which should be a Switch for the platform type\n * @param {Object} props - see PropTypes below\n *\n */\nexport const Switch = forwardRef((props, ref) => {\n  const {\n    className,\n    checked,\n    children,\n    elType,\n    disabled,\n    LeftComponent,\n    close,\n    onChange,\n    onValueChange,\n    RightComponent,\n    styles,\n    SwitchComponent,\n    setCheckedSetter,\n    type,\n    themePath,\n    thumbColor,\n    trackColor,\n    value,\n    ...elProps\n  } = props\n\n  const [ isChecked, setChecked ] = useState(toBool(checked || value))\n\n  // by default, switch manages its own toggled state.\n  // however, if the consumer needs to control that, it can by passing\n  // in a `ref`, then calling ref.current.setChecked to control the value\n  useSwitchHandle(ref, isChecked, setChecked)\n\n  const elThemePath =\n    themePath || `form.switch.${(close && 'close') || 'default'}`\n  const themeStyles = useThemePath(elThemePath, styles)\n  const activeStyles = useCheckedState(isChecked, themeStyles)\n  const typeClassName = useThemeTypeAsClass(\n    elThemePath || type,\n    'keg-switch',\n    className\n  )\n\n  return (\n    (children && (\n      <View\n        className={typeClassName}\n        style={activeStyles.main}\n      >\n        <ChildrenComponent\n          className='keg-switch-container'\n          children={children}\n        />\n      </View>\n    )) || (\n      <View\n        className={typeClassName}\n        style={activeStyles.main}\n      >\n        { LeftComponent && (\n          <SideComponent\n            className='keg-switch-left'\n            Component={LeftComponent}\n            style={activeStyles.content.left}\n          />\n        ) }\n\n        { SwitchComponent ? (\n          renderFromType(SwitchComponent, {\n            ...props,\n            styles: activeStyles.content,\n          })\n        ) : (\n          <KegSwitch\n            elProps={elProps}\n            disabled={disabled}\n            styles={activeStyles.content}\n            {...getSwitchColors(thumbColor, trackColor, activeStyles.content)}\n            {...getChecked(false, isChecked)}\n            {...getOnChangeHandler(\n              false,\n              setCheckedValue(isChecked, setChecked, onChange || onValueChange)\n            )}\n          />\n        ) }\n\n        { RightComponent && (\n          <SideComponent\n            className='keg-switch-right'\n            Component={RightComponent}\n            style={activeStyles.content.right}\n          />\n        ) }\n      </View>\n    )\n  )\n})\n\nSwitch.propTypes = {\n  checked: PropTypes.bool,\n  children: PropTypes.oneOfType([\n    PropTypes.object,\n    PropTypes.string,\n    PropTypes.array,\n  ]),\n  className: PropTypes.oneOfType([ PropTypes.string, PropTypes.array ]),\n  disabled: PropTypes.bool,\n  LeftComponent: PropTypes.oneOfType([\n    PropTypes.object,\n    PropTypes.string,\n    PropTypes.array,\n    PropTypes.func,\n    PropTypes.element,\n  ]),\n  RightComponent: PropTypes.oneOfType([\n    PropTypes.object,\n    PropTypes.string,\n    PropTypes.array,\n    PropTypes.func,\n    PropTypes.element,\n  ]),\n  SwitchComponent: PropTypes.oneOfType([\n    PropTypes.object,\n    PropTypes.string,\n    PropTypes.array,\n    PropTypes.func,\n    PropTypes.element,\n  ]),\n  onChange: PropTypes.func,\n  onValueChange: PropTypes.func,\n  styles: PropTypes.object,\n  text: PropTypes.string,\n  themePath: PropTypes.string,\n  thumbColor: PropTypes.string,\n  trackColor: PropTypes.string,\n  type: PropTypes.string,\n  value: PropTypes.bool,\n}\n","import React from 'react'\nimport { LinkWrapper } from './link.wrapper'\nimport { KegText } from 'KegText'\nimport { Touchable } from '../touchable'\nimport PropTypes from 'prop-types'\nimport { getPlatform } from 'KegGetPlatform'\nimport { useClassList } from 'KegClassList'\n\nconst isWeb = getPlatform() === 'web'\nconst Text = KegText('link')\n\nconst Element = React.forwardRef((props, ref) => {\n  const {\n    children,\n    className,\n    elProps,\n    href,\n    onPress,\n    style,\n    target,\n    ...attrs\n  } = props\n\n  return (\n    <Touchable\n      className={useClassList('keg-link', className)}\n      {...elProps}\n      {...attrs}\n      touchRef={ref}\n    >\n      <Text\n        accessibilityRole='link'\n        className='keg-link-text'\n        style={style}\n        href={href}\n        target={target}\n      >\n        { children }\n      </Text>\n    </Touchable>\n  )\n})\n\nconst Link = props => <LinkWrapper\n  {...props}\n  Element={Element}\n  isWeb={isWeb}\n/>\n\nLink.propTypes = {\n  href: PropTypes.string,\n  onPress: PropTypes.func,\n  text: PropTypes.string,\n  style: PropTypes.object,\n  type: PropTypes.string,\n}\n\nexport { Link, Link as A }\n","import { Values } from 'SVConstants'\nimport { ActiveSession } from 'SVModels/session/activeSession'\nimport { Booking } from 'SVModels/booking'\n\nconst { CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * sessions state\n */\nexport const sessionsState = {\n  [CATEGORIES.SESSIONS]: [],\n  [CATEGORIES.FILTERS]: {\n    [SUB_CATEGORIES.ACTIVE_FILTERS]: [],\n    [SUB_CATEGORIES.SELECTED_FILTERS]: [],\n  },\n  [CATEGORIES.AGENDA_SESSIONS]: {},\n  [CATEGORIES.ACTIVE_SESSION]: new ActiveSession(),\n  [CATEGORIES.BOOKING]: new Booking(),\n  [CATEGORIES.AGENDA_DAYS]: [],\n}\n","import { PendingSession } from 'SVModels/session/pendingSession'\nimport { Values } from 'SVConstants'\nconst { CATEGORIES } = Values\n\n/**\n * pending sessions state\n */\nexport const pendingSessionState = {\n  [CATEGORIES.PENDING_SESSION]: new PendingSession(),\n}\n","import { Values } from 'SVConstants'\nimport { AgendaSettings } from 'SVModels/agendaSettings'\n\nconst { CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * settingsState\n */\nexport const settingsState = {\n  [CATEGORIES.SETTINGS]: {\n    [SUB_CATEGORIES.AGENDA_SETTINGS]: new AgendaSettings(),\n  },\n}\n","import { limbo, isStr, isEmpty, validate } from '@keg-hub/jsutils'\nconst isDev = process.env.NODE_ENV !== 'production'\n\n/**\n * Helper method to log a warning when a method has not been overwritten\n * @function\n * @param {string} methodName - Name of the method that was not overwritten\n * @param {string} logMessage - Function to log the warning message\n *\n * @returns {null}\n */\nconst noOverride = (methodName, logMessage) => {\n  logMessage(\n    `warn`,\n    `The ${methodName} method should be overwritten from a child class!`\n  )\n\n  return null\n}\n\n/**\n * Base Class for the KeyStorage class. Ensures all required methods exist\n * @class\n */\nclass BaseStorage {\n  /**\n   * Creates a promise around a passed in function\n   * Wraps the promise with limbo to get a consistent response an catch errors\n   * @function\n   * @param {function} wrappedFn - Function to wrap in a promise\n   *\n   * @returns {Array} - limbo response array with a length of 2 => [ error, value ]\n   */\n  createPromise = wrappedFn =>\n    // Wrap in limbo to get a consistent response\n    limbo(\n      new Promise((res, rej) => {\n        // Try an call the passed in wrapped function\n        try {\n          res(wrappedFn())\n        }\n        catch (err) {\n          // Catch any errors and reject the promise\n          rej(err)\n        }\n      })\n    )\n\n  /**\n   * Validates the key for a storage function\n   * @param {*} key\n   */\n  validateKey = key => {\n    const [valid] = validate(\n      { key },\n      { key: key => isStr(key) && !isEmpty(key) }\n    )\n\n    return valid\n  }\n\n  /**\n   * Logs a message to the console when not in production\n   * If passed in type is Error, then throw the error when not in production\n   * @function\n   * @param {string} [type='warn'] - Type of message to log\n   * @param {Any} message - message to be loged\n   *\n   * @returns {void}\n   */\n  logMessage = (type = 'log', ...message) => {\n    // If we are in production, just return\n    if (!isDev) return\n\n    // If it's an error, then Throw\n    if (type === 'error') throw new Error(...message)\n\n    // Log all passed in messages message\n    console[type](...message)\n  }\n\n  /**\n   * Placeholder method that should be overwritten by a child class\n   * @function\n   * @returns {null}\n   */\n  getItem = async () => noOverride(`getItem`, this.logMessage)\n\n  /**\n   * Placeholder method that should be overwritten by a child class\n   * @function\n   * @returns {null}\n   */\n  setItem = async () => noOverride(`setItem`, this.logMessage)\n\n  /**\n   * Placeholder method that should be overwritten by a child class\n   * @function\n   * @returns {null}\n   */\n  removeItem = async () => noOverride(`removeItem`, this.logMessage)\n}\n\nexport { BaseStorage }\n","import { BaseStorage } from './baseStorage'\n\n/**\n * Storage Class for web. Saves and retrieves data from local storage\n * @class\n */\nclass Storage extends BaseStorage {\n  constructor(props) {\n    super(props)\n  }\n\n  /**\n   * Gets data from local storage by key using window.localStorage\n   * @function\n   * @param {string} key - Name of the stored value\n   *\n   * @returns {Promise} - Will reject if an error occurred while retrieving the value\n   */\n  getItem = async key => {\n    const [ err, response ] = await this.createPromise(() =>\n      window.localStorage.getItem(key)\n    )\n\n    return err ? this.logMessage('error', err.stack) : response\n  }\n\n  /**\n   * Saves data to local storage by key using using window.localStorage\n   * @function\n   * @param {string} key - Name of the stored value\n   * @param {any} value - The value to store. Size limit is 2048 bytes\n   *\n   * @returns {Promise} - Will reject if value cannot be stored on the device.\n   */\n  setItem = async (key, value) => {\n    const [err] = await this.createPromise(() =>\n      window.localStorage.setItem(key, value)\n    )\n\n    return err ? this.logMessage('error', err.stack) : true\n  }\n\n  /**\n   * Deletes data from local storage by key using window.localStorage\n   * @function\n   * @param {string} key - Name of the stored value\n   *\n   * @returns {Promise} - Will reject if the key / value couldn't be deleted.\n   */\n  removeItem = async key => {\n    const [err] = await this.createPromise(() =>\n      window.localStorage.removeItem(key)\n    )\n\n    return err ? this.logMessage('error', err.stack) : true\n  }\n}\n\nconst KeyStore = new Storage()\n\nexport { KeyStore }\n","import { KeyStore } from 'SVNative/keyStore'\nimport { ActionTypes, Values } from 'SVConstants'\nimport { get, exists, eitherArr, isStr } from '@keg-hub/jsutils'\n\nconst {\n  Plugins: {\n    LocalStorage: { LOADED_FROM_STORAGE },\n  },\n} = Values\n\n// action types to which the plugin responds\nconst updateTypes = new Set([\n  ActionTypes.UPSERT_ITEMS,\n  ActionTypes.UPSERT_ITEM,\n  ActionTypes.SET_ITEM,\n  ActionTypes.SET_ITEMS,\n  ActionTypes.REMOVE_ITEM,\n])\n\n/**\n * Helper for logging errors in the plugin\n * @param {string} msg\n */\nconst logError = msg => console.error(`Plugins - LocalStorage: ${msg}`)\n\n/**\n * @param {object} action\n * @returns { boolean } true if the action payload should be persisted to local storage\n */\nconst shouldPersistPayload = action =>\n  !action[LOADED_FROM_STORAGE] &&\n  updateTypes.has(action.type) &&\n  get(action, 'payload.plugins.localStorage.persist')\n\n/**\n * Removes or stores the item path(s) specified in action.plugins.persist from localStorage.\n * @param {Object} params\n * @param {Object} params.action\n * @param {(string || Array<string>)?} params.action.plugins.persist - the path or paths to persist from the item(s)\n */\nexport const LocalStorage = ({ action = {} } = {}) => {\n  if (!shouldPersistPayload(action)) return { action }\n\n  const { type, payload = {} } = action\n  const { item, items, plugins } = payload\n  const data = payload.key ? item : items\n\n  const persistValue = plugins?.localStorage?.persist\n  const paths = eitherArr(persistValue, [persistValue])\n\n  paths.map(path => {\n    if (!isStr(path) || !path.length)\n      return logError(\n        `Invalid path to ${\n          type === ActionTypes.REMOVE_ITEM ? 'remove' : 'persist'\n        }: \"${path}\"`\n      )\n\n    // if the user defined a specific property in the path to persist (e.g. 'dayNumber'\n    // in the path 'settings.agenda.dayNumber'), we need to extract the value for that\n    // property from the item/items and store that in local storage\n    const [ pathCategory, pathKey, ...propertyKeys ] = path.split('.')\n\n    // if category does not match payload, or if the path contains a key that does not match\n    // the payload, we should not persist.\n    if (\n      pathCategory !== payload.category ||\n      (exists(pathKey) && pathKey !== payload.key)\n    )\n      return logError(\n        `Persist path must start with the same category and key as the payload.\\n\n        payload category and key:  \"${payload.category}.${payload.key}\"\\n\n        payload.plugins.localStorage.persist: \"${path}\"`\n      )\n\n    // extract the value -- if no property keys are set, then this just returns the item(s)\n    const value = get(data, propertyKeys, data)\n\n    // remove or store the value, depending on the action type\n    return type === ActionTypes.REMOVE_ITEM\n      ? KeyStore.removeItem(path)\n      : KeyStore.setItem(path, JSON.stringify(value))\n  })\n\n  return { action }\n}\n","import { pipeline, isObj, isFunc, validate, get } from '@keg-hub/jsutils'\nimport * as KegPlugins from './plugins'\n\n/**\n * Validates the plugin object\n * @param {Object} plugin\n * @returns { boolean } - true if the plugin is a function\n */\nconst isValidPlugin = plugin => {\n  const [valid] = validate(\n    { plugin },\n    { plugin: isFunc },\n    { prefix: `Plugin ${get(plugin, 'name')}:` }\n  )\n  return valid\n}\n\n/**\n * List of plugins that conform to the spec, to be used with the store\n */\nexport const Plugins = Object.values(KegPlugins).filter(isValidPlugin)\n\n/**\n * Exit helper to stop all plugins\n */\nconst exit = () => {\n  throw new Error('Exit plugin pipeline')\n}\n\n/**\n * Verifies that the plugin has returned an object with a processed action\n * @param {Object} result\n */\nconst isValidPluginOutput = (plugin, result) => {\n  const valid = isObj(result) && isObj(result.action)\n  !valid &&\n    console.error(\n      'Plugin',\n      plugin.name || plugin,\n      'did not return the expected result object of form { action: { ... }}, so it will be skipped.'\n    )\n  return valid\n}\n\n/**\n * A list of plugin onDispatch functions. Any invalid output will be omitted from the pipeline\n * @see isValidPluginOutput\n */\nconst updateFunctions = Plugins.map(plugin => params => {\n  const pluginResult = plugin(params)\n\n  // if plugin was invalid, just return the params again\n  return isValidPluginOutput(plugin, pluginResult) ? pluginResult : params\n})\n\n/**\n * Passes the state and action through all the plugins\n * that conduct side effects or transform the state/action before reaching\n * the app reducers\n * @param {Object} action\n */\nexport const runPlugins = ({ action }) => {\n  if (!Plugins || !Plugins.length) return { action }\n\n  try {\n    return pipeline({ action, exit }, ...updateFunctions)\n  }\n  catch (err) {\n    console.error(err)\n    return { action }\n  }\n}\n","import PropTypes from 'prop-types'\nimport React, { useContext, useCallback } from 'react'\nimport { hideActiveModal } from 'SVActions/modals/hideActiveModal'\nimport { ComponentsContext } from 'SVContexts/components/componentsContext'\n\nexport const contentDefaultMaxHeight = 772\n\n/**\n * Renders the modal component (provided by the modal context)\n * @param {object} props\n * @param {object} props.title\n * @param {boolean} props.visible - whether or not the modal is visible\n * @param {Component=} props.Body - Component for the body.\n * @param {Component=} props.Footer - Component for the footer.\n * @param {Function=} props.onDismiss - function that executes when the modal is about to hide itself \n * (e.g. user clicks outside the modal)\n * @example\n *  <BaseModal\n      title={title}\n      visible={visible}\n      Body={BodyComponent}\n      Footer={FooterComponent}\n      onDismiss={() => console.log('on dismiss')}\n    />\n */\nexport const BaseModal = props => {\n  const { title, visible, onDismiss, Body, Footer } = props\n\n  const dismiss = useCallback(() => {\n    onDismiss?.()\n    hideActiveModal()\n  }, [onDismiss])\n\n  const { ModalComponent } = useContext(ComponentsContext)\n\n  return (\n    <ModalComponent\n      modalHeader={title}\n      modalBody={Body}\n      modalFooter={Footer}\n      toggle={dismiss}\n      isOpen={visible}\n    />\n  )\n}\n\nBaseModal.propTypes = {\n  title: PropTypes.string,\n  visible: PropTypes.bool,\n  Body: PropTypes.oneOfType([ PropTypes.func, PropTypes.element ]),\n  Footer: PropTypes.oneOfType([ PropTypes.func, PropTypes.element ]),\n  onDismiss: PropTypes.func,\n}\n","/**\n * Helper to log messages when not in production\n * @param {string} type - Type of log message. Must be one of log, info, dir, warn, error\n * @param {Array} toLog - Data to be logged\n * @example devLog(`warn`, `Action \"setSessionSelected\" requires a valid session. Instead received`, session)\n */\nexport const devLog = (type, ...toLog) =>\n  process.env.NODE_ENV !== 'production' &&\n  console[type] &&\n  console[type](...toLog)\n\n/**\n * shortcuts to devLog\n * @example devLog.log('some log message')\n */\ndevLog.log = (...toLog) => devLog(`log`, ...toLog)\ndevLog.trace = (...toLog) => devLog(`trace`, ...toLog)\ndevLog.debug = (...toLog) => devLog(`debug`, ...toLog)\ndevLog.info = (...toLog) => devLog(`info`, ...toLog)\ndevLog.dir = (...toLog) => devLog(`dir`, ...toLog)\ndevLog.warn = (...toLog) => devLog(`warn`, ...toLog)\ndevLog.error = (...toLog) => devLog(`error`, ...toLog)\n","import * as React from 'react'\nimport { Text, View } from '@keg-hub/keg-components'\n\n/**\n * Digit\n * @param {object} props\n */\nexport const Digit = props => {\n  if (!props.digit) return null\n\n  const { digit, styles } = props\n\n  return (\n    <View\n      className={'ef-button-text-counter-main'}\n      style={styles.main}\n    >\n      <Text\n        className={'ef-button-text-counter'}\n        style={styles.content}\n      >\n        { digit }\n      </Text>\n    </View>\n  )\n}\n","import { Values } from 'SVConstants'\nimport { isPositive, exists } from '@keg-hub/jsutils'\nconst { SESSION_BOOKING_STATES } = Values\n\n/**\n * Checks if the booking display should be disabled from interaction\n * @param {Object} props\n * @param {import('SVModels/session').Session} props.session\n * @param {import('SVModels/PendingSession').PendingSession} props.pendingSession - currently pending session, if there is one\n * @param {Number} props.bookableCount - Attendees that can book the current session\n * @param {string} props.bookingMode - Current mode of booking for the session (single|group)\n * @param {Object} props.timeConflicts - Key value pairs of attendees booked in conflicting sessions. { ${attendeeId}: ${sessionId} }\n * @param {Array<string>} props.bookingList - the list of attendee ids booked to the session\n * @param {Array<string>} props.waitingList - the list of attendee ids on the session's waiting list\n * @param {Object} state\n *\n * @returns {boolean} - If the display interaction should be disabled\n */\nexport const getDisabled = (\n  {\n    session,\n    pendingSession,\n    bookableCount,\n    bookingMode,\n    timeConflicts,\n    bookingList,\n    waitingList,\n  },\n  state\n) => {\n  // if there is a different session awaiting the booking request result, all others are disabled\n  if (\n    pendingSession?.identifier &&\n    pendingSession.identifier !== session.identifier\n  )\n    return true\n  // If state is select, and in single booking mode and there's a time conflict\n  // Then the booking state should be disabled\n  if (\n    state === SESSION_BOOKING_STATES.SELECT &&\n    bookingMode === 'single' &&\n    timeConflicts\n  )\n    return true\n\n  const { capacity, allowBooking } = session\n\n  // no capacity if bookableCount === 0 OR waitingList with spaces is not available\n  const noCapacity =\n    (exists(bookableCount) && !isPositive(bookableCount)) ||\n    !(\n      capacity?.remainingPlaces ||\n      capacity?.isWaitingListAvailable ||\n      capacity?.isUnlimited\n    )\n\n  const hasExistingBookings = Boolean(\n    bookingList?.length || waitingList?.length\n  )\n\n  // disable if there's no space left (and no pre-booked attendees)\n  // or if everyone in the group is booked on a conflicting session\n  return !allowBooking || (noCapacity && !hasExistingBookings)\n}\n","var formatDistanceLocale = {\n  lessThanXSeconds: {\n    one: 'less than a second',\n    other: 'less than {{count}} seconds'\n  },\n  xSeconds: {\n    one: '1 second',\n    other: '{{count}} seconds'\n  },\n  halfAMinute: 'half a minute',\n  lessThanXMinutes: {\n    one: 'less than a minute',\n    other: 'less than {{count}} minutes'\n  },\n  xMinutes: {\n    one: '1 minute',\n    other: '{{count}} minutes'\n  },\n  aboutXHours: {\n    one: 'about 1 hour',\n    other: 'about {{count}} hours'\n  },\n  xHours: {\n    one: '1 hour',\n    other: '{{count}} hours'\n  },\n  xDays: {\n    one: '1 day',\n    other: '{{count}} days'\n  },\n  aboutXWeeks: {\n    one: 'about 1 week',\n    other: 'about {{count}} weeks'\n  },\n  xWeeks: {\n    one: '1 week',\n    other: '{{count}} weeks'\n  },\n  aboutXMonths: {\n    one: 'about 1 month',\n    other: 'about {{count}} months'\n  },\n  xMonths: {\n    one: '1 month',\n    other: '{{count}} months'\n  },\n  aboutXYears: {\n    one: 'about 1 year',\n    other: 'about {{count}} years'\n  },\n  xYears: {\n    one: '1 year',\n    other: '{{count}} years'\n  },\n  overXYears: {\n    one: 'over 1 year',\n    other: 'over {{count}} years'\n  },\n  almostXYears: {\n    one: 'almost 1 year',\n    other: 'almost {{count}} years'\n  }\n};\nexport default function formatDistance(token, count, options) {\n  options = options || {};\n  var result;\n\n  if (typeof formatDistanceLocale[token] === 'string') {\n    result = formatDistanceLocale[token];\n  } else if (count === 1) {\n    result = formatDistanceLocale[token].one;\n  } else {\n    result = formatDistanceLocale[token].other.replace('{{count}}', count);\n  }\n\n  if (options.addSuffix) {\n    if (options.comparison > 0) {\n      return 'in ' + result;\n    } else {\n      return result + ' ago';\n    }\n  }\n\n  return result;\n}","import buildFormatLongFn from '../../../_lib/buildFormatLongFn/index.js';\nvar dateFormats = {\n  full: 'EEEE, MMMM do, y',\n  long: 'MMMM do, y',\n  medium: 'MMM d, y',\n  short: 'MM/dd/yyyy'\n};\nvar timeFormats = {\n  full: 'h:mm:ss a zzzz',\n  long: 'h:mm:ss a z',\n  medium: 'h:mm:ss a',\n  short: 'h:mm a'\n};\nvar dateTimeFormats = {\n  full: \"{{date}} 'at' {{time}}\",\n  long: \"{{date}} 'at' {{time}}\",\n  medium: '{{date}}, {{time}}',\n  short: '{{date}}, {{time}}'\n};\nvar formatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: 'full'\n  }),\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: 'full'\n  }),\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: 'full'\n  })\n};\nexport default formatLong;","export default function buildMatchFn(args) {\n  return function (dirtyString, dirtyOptions) {\n    var string = String(dirtyString);\n    var options = dirtyOptions || {};\n    var width = options.width;\n    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];\n    var matchResult = string.match(matchPattern);\n\n    if (!matchResult) {\n      return null;\n    }\n\n    var matchedString = matchResult[0];\n    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];\n    var value;\n\n    if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {\n      value = findIndex(parsePatterns, function (pattern) {\n        return pattern.test(matchedString);\n      });\n    } else {\n      value = findKey(parsePatterns, function (pattern) {\n        return pattern.test(matchedString);\n      });\n    }\n\n    value = args.valueCallback ? args.valueCallback(value) : value;\n    value = options.valueCallback ? options.valueCallback(value) : value;\n    return {\n      value: value,\n      rest: string.slice(matchedString.length)\n    };\n  };\n}\n\nfunction findKey(object, predicate) {\n  for (var key in object) {\n    if (object.hasOwnProperty(key) && predicate(object[key])) {\n      return key;\n    }\n  }\n}\n\nfunction findIndex(array, predicate) {\n  for (var key = 0; key < array.length; key++) {\n    if (predicate(array[key])) {\n      return key;\n    }\n  }\n}","import buildMatchPatternFn from '../../../_lib/buildMatchPatternFn/index.js';\nimport buildMatchFn from '../../../_lib/buildMatchFn/index.js';\nvar matchOrdinalNumberPattern = /^(\\d+)(th|st|nd|rd)?/i;\nvar parseOrdinalNumberPattern = /\\d+/i;\nvar matchEraPatterns = {\n  narrow: /^(b|a)/i,\n  abbreviated: /^(b\\.?\\s?c\\.?|b\\.?\\s?c\\.?\\s?e\\.?|a\\.?\\s?d\\.?|c\\.?\\s?e\\.?)/i,\n  wide: /^(before christ|before common era|anno domini|common era)/i\n};\nvar parseEraPatterns = {\n  any: [/^b/i, /^(a|c)/i]\n};\nvar matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^q[1234]/i,\n  wide: /^[1234](th|st|nd|rd)? quarter/i\n};\nvar parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i]\n};\nvar matchMonthPatterns = {\n  narrow: /^[jfmasond]/i,\n  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,\n  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i\n};\nvar parseMonthPatterns = {\n  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],\n  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]\n};\nvar matchDayPatterns = {\n  narrow: /^[smtwf]/i,\n  short: /^(su|mo|tu|we|th|fr|sa)/i,\n  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,\n  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i\n};\nvar parseDayPatterns = {\n  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],\n  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]\n};\nvar matchDayPeriodPatterns = {\n  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,\n  any: /^([ap]\\.?\\s?m\\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i\n};\nvar parseDayPeriodPatterns = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^mi/i,\n    noon: /^no/i,\n    morning: /morning/i,\n    afternoon: /afternoon/i,\n    evening: /evening/i,\n    night: /night/i\n  }\n};\nvar match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: function (value) {\n      return parseInt(value, 10);\n    }\n  }),\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: 'wide',\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: 'any'\n  }),\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: 'wide',\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: 'any',\n    valueCallback: function (index) {\n      return index + 1;\n    }\n  }),\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: 'wide',\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: 'any'\n  }),\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: 'wide',\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: 'any'\n  }),\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: 'any',\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: 'any'\n  })\n};\nexport default match;","import buildLocalizeFn from '../../../_lib/buildLocalizeFn/index.js';\nvar eraValues = {\n  narrow: ['B', 'A'],\n  abbreviated: ['BC', 'AD'],\n  wide: ['Before Christ', 'Anno Domini']\n};\nvar quarterValues = {\n  narrow: ['1', '2', '3', '4'],\n  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],\n  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.\n  // If you are making a new locale based on this one, check if the same is true for the language you're working on.\n  // Generally, formatted dates should look like they are in the middle of a sentence,\n  // e.g. in Spanish language the weekdays and months should be in the lowercase.\n\n};\nvar monthValues = {\n  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],\n  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']\n};\nvar dayValues = {\n  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n};\nvar dayPeriodValues = {\n  narrow: {\n    am: 'a',\n    pm: 'p',\n    midnight: 'mi',\n    noon: 'n',\n    morning: 'morning',\n    afternoon: 'afternoon',\n    evening: 'evening',\n    night: 'night'\n  },\n  abbreviated: {\n    am: 'AM',\n    pm: 'PM',\n    midnight: 'midnight',\n    noon: 'noon',\n    morning: 'morning',\n    afternoon: 'afternoon',\n    evening: 'evening',\n    night: 'night'\n  },\n  wide: {\n    am: 'a.m.',\n    pm: 'p.m.',\n    midnight: 'midnight',\n    noon: 'noon',\n    morning: 'morning',\n    afternoon: 'afternoon',\n    evening: 'evening',\n    night: 'night'\n  }\n};\nvar formattingDayPeriodValues = {\n  narrow: {\n    am: 'a',\n    pm: 'p',\n    midnight: 'mi',\n    noon: 'n',\n    morning: 'in the morning',\n    afternoon: 'in the afternoon',\n    evening: 'in the evening',\n    night: 'at night'\n  },\n  abbreviated: {\n    am: 'AM',\n    pm: 'PM',\n    midnight: 'midnight',\n    noon: 'noon',\n    morning: 'in the morning',\n    afternoon: 'in the afternoon',\n    evening: 'in the evening',\n    night: 'at night'\n  },\n  wide: {\n    am: 'a.m.',\n    pm: 'p.m.',\n    midnight: 'midnight',\n    noon: 'noon',\n    morning: 'in the morning',\n    afternoon: 'in the afternoon',\n    evening: 'in the evening',\n    night: 'at night'\n  }\n};\n\nfunction ordinalNumber(dirtyNumber, _dirtyOptions) {\n  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,\n  // if they are different for different grammatical genders,\n  // use `options.unit`:\n  //\n  //   var options = dirtyOptions || {}\n  //   var unit = String(options.unit)\n  //\n  // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',\n  // 'day', 'hour', 'minute', 'second'\n\n  var rem100 = number % 100;\n\n  if (rem100 > 20 || rem100 < 10) {\n    switch (rem100 % 10) {\n      case 1:\n        return number + 'st';\n\n      case 2:\n        return number + 'nd';\n\n      case 3:\n        return number + 'rd';\n    }\n  }\n\n  return number + 'th';\n}\n\nvar localize = {\n  ordinalNumber: ordinalNumber,\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: 'wide'\n  }),\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: 'wide',\n    argumentCallback: function (quarter) {\n      return Number(quarter) - 1;\n    }\n  }),\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: 'wide'\n  }),\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: 'wide'\n  }),\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: 'wide',\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: 'wide'\n  })\n};\nexport default localize;","import addLeadingZeros from '../../addLeadingZeros/index.js';\n/*\n * |     | Unit                           |     | Unit                           |\n * |-----|--------------------------------|-----|--------------------------------|\n * |  a  | AM, PM                         |  A* |                                |\n * |  d  | Day of month                   |  D  |                                |\n * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |\n * |  m  | Minute                         |  M  | Month                          |\n * |  s  | Second                         |  S  | Fraction of second             |\n * |  y  | Year (abs)                     |  Y  |                                |\n *\n * Letters marked by * are not implemented but reserved by Unicode standard.\n */\n\nvar formatters = {\n  // Year\n  y: function (date, token) {\n    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens\n    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |\n    // |----------|-------|----|-------|-------|-------|\n    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |\n    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |\n    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |\n    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |\n    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |\n    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)\n\n    var year = signedYear > 0 ? signedYear : 1 - signedYear;\n    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);\n  },\n  // Month\n  M: function (date, token) {\n    var month = date.getUTCMonth();\n    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);\n  },\n  // Day of the month\n  d: function (date, token) {\n    return addLeadingZeros(date.getUTCDate(), token.length);\n  },\n  // AM or PM\n  a: function (date, token) {\n    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';\n\n    switch (token) {\n      case 'a':\n      case 'aa':\n      case 'aaa':\n        return dayPeriodEnumValue.toUpperCase();\n\n      case 'aaaaa':\n        return dayPeriodEnumValue[0];\n\n      case 'aaaa':\n      default:\n        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';\n    }\n  },\n  // Hour [1-12]\n  h: function (date, token) {\n    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);\n  },\n  // Hour [0-23]\n  H: function (date, token) {\n    return addLeadingZeros(date.getUTCHours(), token.length);\n  },\n  // Minute\n  m: function (date, token) {\n    return addLeadingZeros(date.getUTCMinutes(), token.length);\n  },\n  // Second\n  s: function (date, token) {\n    return addLeadingZeros(date.getUTCSeconds(), token.length);\n  },\n  // Fraction of second\n  S: function (date, token) {\n    var numberOfDigits = token.length;\n    var milliseconds = date.getUTCMilliseconds();\n    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));\n    return addLeadingZeros(fractionalSeconds, token.length);\n  }\n};\nexport default formatters;","import lightFormatters from '../lightFormatters/index.js';\nimport getUTCDayOfYear from '../../../_lib/getUTCDayOfYear/index.js';\nimport getUTCISOWeek from '../../../_lib/getUTCISOWeek/index.js';\nimport getUTCISOWeekYear from '../../../_lib/getUTCISOWeekYear/index.js';\nimport getUTCWeek from '../../../_lib/getUTCWeek/index.js';\nimport getUTCWeekYear from '../../../_lib/getUTCWeekYear/index.js';\nimport addLeadingZeros from '../../addLeadingZeros/index.js';\nvar dayPeriodEnum = {\n  am: 'am',\n  pm: 'pm',\n  midnight: 'midnight',\n  noon: 'noon',\n  morning: 'morning',\n  afternoon: 'afternoon',\n  evening: 'evening',\n  night: 'night'\n  /*\n   * |     | Unit                           |     | Unit                           |\n   * |-----|--------------------------------|-----|--------------------------------|\n   * |  a  | AM, PM                         |  A* | Milliseconds in day            |\n   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |\n   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |\n   * |  d  | Day of month                   |  D  | Day of year                    |\n   * |  e  | Local day of week              |  E  | Day of week                    |\n   * |  f  |                                |  F* | Day of week in month           |\n   * |  g* | Modified Julian day            |  G  | Era                            |\n   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |\n   * |  i! | ISO day of week                |  I! | ISO week of year               |\n   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |\n   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |\n   * |  l* | (deprecated)                   |  L  | Stand-alone month              |\n   * |  m  | Minute                         |  M  | Month                          |\n   * |  n  |                                |  N  |                                |\n   * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |\n   * |  p! | Long localized time            |  P! | Long localized date            |\n   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |\n   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |\n   * |  s  | Second                         |  S  | Fraction of second             |\n   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |\n   * |  u  | Extended year                  |  U* | Cyclic year                    |\n   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |\n   * |  w  | Local week of year             |  W* | Week of month                  |\n   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |\n   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |\n   * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |\n   *\n   * Letters marked by * are not implemented but reserved by Unicode standard.\n   *\n   * Letters marked by ! are non-standard, but implemented by date-fns:\n   * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)\n   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,\n   *   i.e. 7 for Sunday, 1 for Monday, etc.\n   * - `I` is ISO week of year, as opposed to `w` which is local week of year.\n   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.\n   *   `R` is supposed to be used in conjunction with `I` and `i`\n   *   for universal ISO week-numbering date, whereas\n   *   `Y` is supposed to be used in conjunction with `w` and `e`\n   *   for week-numbering date specific to the locale.\n   * - `P` is long localized date format\n   * - `p` is long localized time format\n   */\n\n};\nvar formatters = {\n  // Era\n  G: function (date, token, localize) {\n    var era = date.getUTCFullYear() > 0 ? 1 : 0;\n\n    switch (token) {\n      // AD, BC\n      case 'G':\n      case 'GG':\n      case 'GGG':\n        return localize.era(era, {\n          width: 'abbreviated'\n        });\n      // A, B\n\n      case 'GGGGG':\n        return localize.era(era, {\n          width: 'narrow'\n        });\n      // Anno Domini, Before Christ\n\n      case 'GGGG':\n      default:\n        return localize.era(era, {\n          width: 'wide'\n        });\n    }\n  },\n  // Year\n  y: function (date, token, localize) {\n    // Ordinal number\n    if (token === 'yo') {\n      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)\n\n      var year = signedYear > 0 ? signedYear : 1 - signedYear;\n      return localize.ordinalNumber(year, {\n        unit: 'year'\n      });\n    }\n\n    return lightFormatters.y(date, token);\n  },\n  // Local week-numbering year\n  Y: function (date, token, localize, options) {\n    var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)\n\n    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year\n\n    if (token === 'YY') {\n      var twoDigitYear = weekYear % 100;\n      return addLeadingZeros(twoDigitYear, 2);\n    } // Ordinal number\n\n\n    if (token === 'Yo') {\n      return localize.ordinalNumber(weekYear, {\n        unit: 'year'\n      });\n    } // Padding\n\n\n    return addLeadingZeros(weekYear, token.length);\n  },\n  // ISO week-numbering year\n  R: function (date, token) {\n    var isoWeekYear = getUTCISOWeekYear(date); // Padding\n\n    return addLeadingZeros(isoWeekYear, token.length);\n  },\n  // Extended year. This is a single number designating the year of this calendar system.\n  // The main difference between `y` and `u` localizers are B.C. years:\n  // | Year | `y` | `u` |\n  // |------|-----|-----|\n  // | AC 1 |   1 |   1 |\n  // | BC 1 |   1 |   0 |\n  // | BC 2 |   2 |  -1 |\n  // Also `yy` always returns the last two digits of a year,\n  // while `uu` pads single digit years to 2 characters and returns other years unchanged.\n  u: function (date, token) {\n    var year = date.getUTCFullYear();\n    return addLeadingZeros(year, token.length);\n  },\n  // Quarter\n  Q: function (date, token, localize) {\n    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);\n\n    switch (token) {\n      // 1, 2, 3, 4\n      case 'Q':\n        return String(quarter);\n      // 01, 02, 03, 04\n\n      case 'QQ':\n        return addLeadingZeros(quarter, 2);\n      // 1st, 2nd, 3rd, 4th\n\n      case 'Qo':\n        return localize.ordinalNumber(quarter, {\n          unit: 'quarter'\n        });\n      // Q1, Q2, Q3, Q4\n\n      case 'QQQ':\n        return localize.quarter(quarter, {\n          width: 'abbreviated',\n          context: 'formatting'\n        });\n      // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n\n      case 'QQQQQ':\n        return localize.quarter(quarter, {\n          width: 'narrow',\n          context: 'formatting'\n        });\n      // 1st quarter, 2nd quarter, ...\n\n      case 'QQQQ':\n      default:\n        return localize.quarter(quarter, {\n          width: 'wide',\n          context: 'formatting'\n        });\n    }\n  },\n  // Stand-alone quarter\n  q: function (date, token, localize) {\n    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);\n\n    switch (token) {\n      // 1, 2, 3, 4\n      case 'q':\n        return String(quarter);\n      // 01, 02, 03, 04\n\n      case 'qq':\n        return addLeadingZeros(quarter, 2);\n      // 1st, 2nd, 3rd, 4th\n\n      case 'qo':\n        return localize.ordinalNumber(quarter, {\n          unit: 'quarter'\n        });\n      // Q1, Q2, Q3, Q4\n\n      case 'qqq':\n        return localize.quarter(quarter, {\n          width: 'abbreviated',\n          context: 'standalone'\n        });\n      // 1, 2, 3, 4 (narrow quarter; could be not numerical)\n\n      case 'qqqqq':\n        return localize.quarter(quarter, {\n          width: 'narrow',\n          context: 'standalone'\n        });\n      // 1st quarter, 2nd quarter, ...\n\n      case 'qqqq':\n      default:\n        return localize.quarter(quarter, {\n          width: 'wide',\n          context: 'standalone'\n        });\n    }\n  },\n  // Month\n  M: function (date, token, localize) {\n    var month = date.getUTCMonth();\n\n    switch (token) {\n      case 'M':\n      case 'MM':\n        return lightFormatters.M(date, token);\n      // 1st, 2nd, ..., 12th\n\n      case 'Mo':\n        return localize.ordinalNumber(month + 1, {\n          unit: 'month'\n        });\n      // Jan, Feb, ..., Dec\n\n      case 'MMM':\n        return localize.month(month, {\n          width: 'abbreviated',\n          context: 'formatting'\n        });\n      // J, F, ..., D\n\n      case 'MMMMM':\n        return localize.month(month, {\n          width: 'narrow',\n          context: 'formatting'\n        });\n      // January, February, ..., December\n\n      case 'MMMM':\n      default:\n        return localize.month(month, {\n          width: 'wide',\n          context: 'formatting'\n        });\n    }\n  },\n  // Stand-alone month\n  L: function (date, token, localize) {\n    var month = date.getUTCMonth();\n\n    switch (token) {\n      // 1, 2, ..., 12\n      case 'L':\n        return String(month + 1);\n      // 01, 02, ..., 12\n\n      case 'LL':\n        return addLeadingZeros(month + 1, 2);\n      // 1st, 2nd, ..., 12th\n\n      case 'Lo':\n        return localize.ordinalNumber(month + 1, {\n          unit: 'month'\n        });\n      // Jan, Feb, ..., Dec\n\n      case 'LLL':\n        return localize.month(month, {\n          width: 'abbreviated',\n          context: 'standalone'\n        });\n      // J, F, ..., D\n\n      case 'LLLLL':\n        return localize.month(month, {\n          width: 'narrow',\n          context: 'standalone'\n        });\n      // January, February, ..., December\n\n      case 'LLLL':\n      default:\n        return localize.month(month, {\n          width: 'wide',\n          context: 'standalone'\n        });\n    }\n  },\n  // Local week of year\n  w: function (date, token, localize, options) {\n    var week = getUTCWeek(date, options);\n\n    if (token === 'wo') {\n      return localize.ordinalNumber(week, {\n        unit: 'week'\n      });\n    }\n\n    return addLeadingZeros(week, token.length);\n  },\n  // ISO week of year\n  I: function (date, token, localize) {\n    var isoWeek = getUTCISOWeek(date);\n\n    if (token === 'Io') {\n      return localize.ordinalNumber(isoWeek, {\n        unit: 'week'\n      });\n    }\n\n    return addLeadingZeros(isoWeek, token.length);\n  },\n  // Day of the month\n  d: function (date, token, localize) {\n    if (token === 'do') {\n      return localize.ordinalNumber(date.getUTCDate(), {\n        unit: 'date'\n      });\n    }\n\n    return lightFormatters.d(date, token);\n  },\n  // Day of year\n  D: function (date, token, localize) {\n    var dayOfYear = getUTCDayOfYear(date);\n\n    if (token === 'Do') {\n      return localize.ordinalNumber(dayOfYear, {\n        unit: 'dayOfYear'\n      });\n    }\n\n    return addLeadingZeros(dayOfYear, token.length);\n  },\n  // Day of week\n  E: function (date, token, localize) {\n    var dayOfWeek = date.getUTCDay();\n\n    switch (token) {\n      // Tue\n      case 'E':\n      case 'EE':\n      case 'EEE':\n        return localize.day(dayOfWeek, {\n          width: 'abbreviated',\n          context: 'formatting'\n        });\n      // T\n\n      case 'EEEEE':\n        return localize.day(dayOfWeek, {\n          width: 'narrow',\n          context: 'formatting'\n        });\n      // Tu\n\n      case 'EEEEEE':\n        return localize.day(dayOfWeek, {\n          width: 'short',\n          context: 'formatting'\n        });\n      // Tuesday\n\n      case 'EEEE':\n      default:\n        return localize.day(dayOfWeek, {\n          width: 'wide',\n          context: 'formatting'\n        });\n    }\n  },\n  // Local day of week\n  e: function (date, token, localize, options) {\n    var dayOfWeek = date.getUTCDay();\n    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;\n\n    switch (token) {\n      // Numerical value (Nth day of week with current locale or weekStartsOn)\n      case 'e':\n        return String(localDayOfWeek);\n      // Padded numerical value\n\n      case 'ee':\n        return addLeadingZeros(localDayOfWeek, 2);\n      // 1st, 2nd, ..., 7th\n\n      case 'eo':\n        return localize.ordinalNumber(localDayOfWeek, {\n          unit: 'day'\n        });\n\n      case 'eee':\n        return localize.day(dayOfWeek, {\n          width: 'abbreviated',\n          context: 'formatting'\n        });\n      // T\n\n      case 'eeeee':\n        return localize.day(dayOfWeek, {\n          width: 'narrow',\n          context: 'formatting'\n        });\n      // Tu\n\n      case 'eeeeee':\n        return localize.day(dayOfWeek, {\n          width: 'short',\n          context: 'formatting'\n        });\n      // Tuesday\n\n      case 'eeee':\n      default:\n        return localize.day(dayOfWeek, {\n          width: 'wide',\n          context: 'formatting'\n        });\n    }\n  },\n  // Stand-alone local day of week\n  c: function (date, token, localize, options) {\n    var dayOfWeek = date.getUTCDay();\n    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;\n\n    switch (token) {\n      // Numerical value (same as in `e`)\n      case 'c':\n        return String(localDayOfWeek);\n      // Padded numerical value\n\n      case 'cc':\n        return addLeadingZeros(localDayOfWeek, token.length);\n      // 1st, 2nd, ..., 7th\n\n      case 'co':\n        return localize.ordinalNumber(localDayOfWeek, {\n          unit: 'day'\n        });\n\n      case 'ccc':\n        return localize.day(dayOfWeek, {\n          width: 'abbreviated',\n          context: 'standalone'\n        });\n      // T\n\n      case 'ccccc':\n        return localize.day(dayOfWeek, {\n          width: 'narrow',\n          context: 'standalone'\n        });\n      // Tu\n\n      case 'cccccc':\n        return localize.day(dayOfWeek, {\n          width: 'short',\n          context: 'standalone'\n        });\n      // Tuesday\n\n      case 'cccc':\n      default:\n        return localize.day(dayOfWeek, {\n          width: 'wide',\n          context: 'standalone'\n        });\n    }\n  },\n  // ISO day of week\n  i: function (date, token, localize) {\n    var dayOfWeek = date.getUTCDay();\n    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;\n\n    switch (token) {\n      // 2\n      case 'i':\n        return String(isoDayOfWeek);\n      // 02\n\n      case 'ii':\n        return addLeadingZeros(isoDayOfWeek, token.length);\n      // 2nd\n\n      case 'io':\n        return localize.ordinalNumber(isoDayOfWeek, {\n          unit: 'day'\n        });\n      // Tue\n\n      case 'iii':\n        return localize.day(dayOfWeek, {\n          width: 'abbreviated',\n          context: 'formatting'\n        });\n      // T\n\n      case 'iiiii':\n        return localize.day(dayOfWeek, {\n          width: 'narrow',\n          context: 'formatting'\n        });\n      // Tu\n\n      case 'iiiiii':\n        return localize.day(dayOfWeek, {\n          width: 'short',\n          context: 'formatting'\n        });\n      // Tuesday\n\n      case 'iiii':\n      default:\n        return localize.day(dayOfWeek, {\n          width: 'wide',\n          context: 'formatting'\n        });\n    }\n  },\n  // AM or PM\n  a: function (date, token, localize) {\n    var hours = date.getUTCHours();\n    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';\n\n    switch (token) {\n      case 'a':\n      case 'aa':\n      case 'aaa':\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'abbreviated',\n          context: 'formatting'\n        });\n\n      case 'aaaaa':\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'narrow',\n          context: 'formatting'\n        });\n\n      case 'aaaa':\n      default:\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'wide',\n          context: 'formatting'\n        });\n    }\n  },\n  // AM, PM, midnight, noon\n  b: function (date, token, localize) {\n    var hours = date.getUTCHours();\n    var dayPeriodEnumValue;\n\n    if (hours === 12) {\n      dayPeriodEnumValue = dayPeriodEnum.noon;\n    } else if (hours === 0) {\n      dayPeriodEnumValue = dayPeriodEnum.midnight;\n    } else {\n      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';\n    }\n\n    switch (token) {\n      case 'b':\n      case 'bb':\n      case 'bbb':\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'abbreviated',\n          context: 'formatting'\n        });\n\n      case 'bbbbb':\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'narrow',\n          context: 'formatting'\n        });\n\n      case 'bbbb':\n      default:\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'wide',\n          context: 'formatting'\n        });\n    }\n  },\n  // in the morning, in the afternoon, in the evening, at night\n  B: function (date, token, localize) {\n    var hours = date.getUTCHours();\n    var dayPeriodEnumValue;\n\n    if (hours >= 17) {\n      dayPeriodEnumValue = dayPeriodEnum.evening;\n    } else if (hours >= 12) {\n      dayPeriodEnumValue = dayPeriodEnum.afternoon;\n    } else if (hours >= 4) {\n      dayPeriodEnumValue = dayPeriodEnum.morning;\n    } else {\n      dayPeriodEnumValue = dayPeriodEnum.night;\n    }\n\n    switch (token) {\n      case 'B':\n      case 'BB':\n      case 'BBB':\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'abbreviated',\n          context: 'formatting'\n        });\n\n      case 'BBBBB':\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'narrow',\n          context: 'formatting'\n        });\n\n      case 'BBBB':\n      default:\n        return localize.dayPeriod(dayPeriodEnumValue, {\n          width: 'wide',\n          context: 'formatting'\n        });\n    }\n  },\n  // Hour [1-12]\n  h: function (date, token, localize) {\n    if (token === 'ho') {\n      var hours = date.getUTCHours() % 12;\n      if (hours === 0) hours = 12;\n      return localize.ordinalNumber(hours, {\n        unit: 'hour'\n      });\n    }\n\n    return lightFormatters.h(date, token);\n  },\n  // Hour [0-23]\n  H: function (date, token, localize) {\n    if (token === 'Ho') {\n      return localize.ordinalNumber(date.getUTCHours(), {\n        unit: 'hour'\n      });\n    }\n\n    return lightFormatters.H(date, token);\n  },\n  // Hour [0-11]\n  K: function (date, token, localize) {\n    var hours = date.getUTCHours() % 12;\n\n    if (token === 'Ko') {\n      return localize.ordinalNumber(hours, {\n        unit: 'hour'\n      });\n    }\n\n    return addLeadingZeros(hours, token.length);\n  },\n  // Hour [1-24]\n  k: function (date, token, localize) {\n    var hours = date.getUTCHours();\n    if (hours === 0) hours = 24;\n\n    if (token === 'ko') {\n      return localize.ordinalNumber(hours, {\n        unit: 'hour'\n      });\n    }\n\n    return addLeadingZeros(hours, token.length);\n  },\n  // Minute\n  m: function (date, token, localize) {\n    if (token === 'mo') {\n      return localize.ordinalNumber(date.getUTCMinutes(), {\n        unit: 'minute'\n      });\n    }\n\n    return lightFormatters.m(date, token);\n  },\n  // Second\n  s: function (date, token, localize) {\n    if (token === 'so') {\n      return localize.ordinalNumber(date.getUTCSeconds(), {\n        unit: 'second'\n      });\n    }\n\n    return lightFormatters.s(date, token);\n  },\n  // Fraction of second\n  S: function (date, token) {\n    return lightFormatters.S(date, token);\n  },\n  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)\n  X: function (date, token, _localize, options) {\n    var originalDate = options._originalDate || date;\n    var timezoneOffset = originalDate.getTimezoneOffset();\n\n    if (timezoneOffset === 0) {\n      return 'Z';\n    }\n\n    switch (token) {\n      // Hours and optional minutes\n      case 'X':\n        return formatTimezoneWithOptionalMinutes(timezoneOffset);\n      // Hours, minutes and optional seconds without `:` delimiter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `XX`\n\n      case 'XXXX':\n      case 'XX':\n        // Hours and minutes without `:` delimiter\n        return formatTimezone(timezoneOffset);\n      // Hours, minutes and optional seconds with `:` delimiter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `XXX`\n\n      case 'XXXXX':\n      case 'XXX': // Hours and minutes with `:` delimiter\n\n      default:\n        return formatTimezone(timezoneOffset, ':');\n    }\n  },\n  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)\n  x: function (date, token, _localize, options) {\n    var originalDate = options._originalDate || date;\n    var timezoneOffset = originalDate.getTimezoneOffset();\n\n    switch (token) {\n      // Hours and optional minutes\n      case 'x':\n        return formatTimezoneWithOptionalMinutes(timezoneOffset);\n      // Hours, minutes and optional seconds without `:` delimiter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `xx`\n\n      case 'xxxx':\n      case 'xx':\n        // Hours and minutes without `:` delimiter\n        return formatTimezone(timezoneOffset);\n      // Hours, minutes and optional seconds with `:` delimiter\n      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets\n      // so this token always has the same output as `xxx`\n\n      case 'xxxxx':\n      case 'xxx': // Hours and minutes with `:` delimiter\n\n      default:\n        return formatTimezone(timezoneOffset, ':');\n    }\n  },\n  // Timezone (GMT)\n  O: function (date, token, _localize, options) {\n    var originalDate = options._originalDate || date;\n    var timezoneOffset = originalDate.getTimezoneOffset();\n\n    switch (token) {\n      // Short\n      case 'O':\n      case 'OO':\n      case 'OOO':\n        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');\n      // Long\n\n      case 'OOOO':\n      default:\n        return 'GMT' + formatTimezone(timezoneOffset, ':');\n    }\n  },\n  // Timezone (specific non-location)\n  z: function (date, token, _localize, options) {\n    var originalDate = options._originalDate || date;\n    var timezoneOffset = originalDate.getTimezoneOffset();\n\n    switch (token) {\n      // Short\n      case 'z':\n      case 'zz':\n      case 'zzz':\n        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');\n      // Long\n\n      case 'zzzz':\n      default:\n        return 'GMT' + formatTimezone(timezoneOffset, ':');\n    }\n  },\n  // Seconds timestamp\n  t: function (date, token, _localize, options) {\n    var originalDate = options._originalDate || date;\n    var timestamp = Math.floor(originalDate.getTime() / 1000);\n    return addLeadingZeros(timestamp, token.length);\n  },\n  // Milliseconds timestamp\n  T: function (date, token, _localize, options) {\n    var originalDate = options._originalDate || date;\n    var timestamp = originalDate.getTime();\n    return addLeadingZeros(timestamp, token.length);\n  }\n};\n\nfunction formatTimezoneShort(offset, dirtyDelimiter) {\n  var sign = offset > 0 ? '-' : '+';\n  var absOffset = Math.abs(offset);\n  var hours = Math.floor(absOffset / 60);\n  var minutes = absOffset % 60;\n\n  if (minutes === 0) {\n    return sign + String(hours);\n  }\n\n  var delimiter = dirtyDelimiter || '';\n  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);\n}\n\nfunction formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {\n  if (offset % 60 === 0) {\n    var sign = offset > 0 ? '-' : '+';\n    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);\n  }\n\n  return formatTimezone(offset, dirtyDelimiter);\n}\n\nfunction formatTimezone(offset, dirtyDelimiter) {\n  var delimiter = dirtyDelimiter || '';\n  var sign = offset > 0 ? '-' : '+';\n  var absOffset = Math.abs(offset);\n  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);\n  var minutes = addLeadingZeros(absOffset % 60, 2);\n  return sign + hours + delimiter + minutes;\n}\n\nexport default formatters;","function dateLongFormatter(pattern, formatLong) {\n  switch (pattern) {\n    case 'P':\n      return formatLong.date({\n        width: 'short'\n      });\n\n    case 'PP':\n      return formatLong.date({\n        width: 'medium'\n      });\n\n    case 'PPP':\n      return formatLong.date({\n        width: 'long'\n      });\n\n    case 'PPPP':\n    default:\n      return formatLong.date({\n        width: 'full'\n      });\n  }\n}\n\nfunction timeLongFormatter(pattern, formatLong) {\n  switch (pattern) {\n    case 'p':\n      return formatLong.time({\n        width: 'short'\n      });\n\n    case 'pp':\n      return formatLong.time({\n        width: 'medium'\n      });\n\n    case 'ppp':\n      return formatLong.time({\n        width: 'long'\n      });\n\n    case 'pppp':\n    default:\n      return formatLong.time({\n        width: 'full'\n      });\n  }\n}\n\nfunction dateTimeLongFormatter(pattern, formatLong) {\n  var matchResult = pattern.match(/(P+)(p+)?/);\n  var datePattern = matchResult[1];\n  var timePattern = matchResult[2];\n\n  if (!timePattern) {\n    return dateLongFormatter(pattern, formatLong);\n  }\n\n  var dateTimeFormat;\n\n  switch (datePattern) {\n    case 'P':\n      dateTimeFormat = formatLong.dateTime({\n        width: 'short'\n      });\n      break;\n\n    case 'PP':\n      dateTimeFormat = formatLong.dateTime({\n        width: 'medium'\n      });\n      break;\n\n    case 'PPP':\n      dateTimeFormat = formatLong.dateTime({\n        width: 'long'\n      });\n      break;\n\n    case 'PPPP':\n    default:\n      dateTimeFormat = formatLong.dateTime({\n        width: 'full'\n      });\n      break;\n  }\n\n  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));\n}\n\nvar longFormatters = {\n  p: timeLongFormatter,\n  P: dateTimeLongFormatter\n};\nexport default longFormatters;","import isValid from '../isValid/index.js';\nimport defaultLocale from '../locale/en-US/index.js';\nimport subMilliseconds from '../subMilliseconds/index.js';\nimport toDate from '../toDate/index.js';\nimport formatters from '../_lib/format/formatters/index.js';\nimport longFormatters from '../_lib/format/longFormatters/index.js';\nimport getTimezoneOffsetInMilliseconds from '../_lib/getTimezoneOffsetInMilliseconds/index.js';\nimport { isProtectedDayOfYearToken, isProtectedWeekYearToken, throwProtectedError } from '../_lib/protectedTokens/index.js';\nimport toInteger from '../_lib/toInteger/index.js';\nimport requiredArgs from '../_lib/requiredArgs/index.js'; // This RegExp consists of three parts separated by `|`:\n// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token\n//   (one of the certain letters followed by `o`)\n// - (\\w)\\1* matches any sequences of the same letter\n// - '' matches two quote characters in a row\n// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),\n//   except a single quote symbol, which ends the sequence.\n//   Two quote characters do not end the sequence.\n//   If there is no matching single quote\n//   then the sequence will continue until the end of the string.\n// - . matches any single character unmatched by previous parts of the RegExps\n\nvar formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\\w)\\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also\n// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`\n\nvar longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;\nvar escapedStringRegExp = /^'([^]*?)'?$/;\nvar doubleQuoteRegExp = /''/g;\nvar unescapedLatinCharacterRegExp = /[a-zA-Z]/;\n/**\n * @name format\n * @category Common Helpers\n * @summary Format the date.\n *\n * @description\n * Return the formatted date string in the given format. The result may vary by locale.\n *\n * >  Please note that the `format` tokens differ from Moment.js and other libraries.\n * > See: https://git.io/fxCyr\n *\n * The characters wrapped between two single quotes characters (') are escaped.\n * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n * (see the last example)\n *\n * Format of the string is based on Unicode Technical Standard #35:\n * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * with a few additions (see note 7 below the table).\n *\n * Accepted patterns:\n * | Unit                            | Pattern | Result examples                   | Notes |\n * |---------------------------------|---------|-----------------------------------|-------|\n * | Era                             | G..GGG  | AD, BC                            |       |\n * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |\n * |                                 | GGGGG   | A, B                              |       |\n * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |\n * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |\n * |                                 | yy      | 44, 01, 00, 17                    | 5     |\n * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |\n * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |\n * |                                 | yyyyy   | ...                               | 3,5   |\n * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |\n * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |\n * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |\n * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |\n * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |\n * |                                 | YYYYY   | ...                               | 3,5   |\n * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |\n * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |\n * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |\n * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |\n * |                                 | RRRRR   | ...                               | 3,5,7 |\n * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |\n * |                                 | uu      | -43, 01, 1900, 2017               | 5     |\n * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |\n * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |\n * |                                 | uuuuu   | ...                               | 3,5   |\n * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |\n * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |\n * |                                 | QQ      | 01, 02, 03, 04                    |       |\n * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |\n * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |\n * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |\n * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |\n * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |\n * |                                 | qq      | 01, 02, 03, 04                    |       |\n * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |\n * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |\n * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |\n * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |\n * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |\n * |                                 | MM      | 01, 02, ..., 12                   |       |\n * |                                 | MMM     | Jan, Feb, ..., Dec                |       |\n * |                                 | MMMM    | January, February, ..., December  | 2     |\n * |                                 | MMMMM   | J, F, ..., D                      |       |\n * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |\n * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |\n * |                                 | LL      | 01, 02, ..., 12                   |       |\n * |                                 | LLL     | Jan, Feb, ..., Dec                |       |\n * |                                 | LLLL    | January, February, ..., December  | 2     |\n * |                                 | LLLLL   | J, F, ..., D                      |       |\n * | Local week of year              | w       | 1, 2, ..., 53                     |       |\n * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |\n * |                                 | ww      | 01, 02, ..., 53                   |       |\n * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |\n * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |\n * |                                 | II      | 01, 02, ..., 53                   | 7     |\n * | Day of month                    | d       | 1, 2, ..., 31                     |       |\n * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |\n * |                                 | dd      | 01, 02, ..., 31                   |       |\n * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |\n * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |\n * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |\n * |                                 | DDD     | 001, 002, ..., 365, 366           |       |\n * |                                 | DDDD    | ...                               | 3     |\n * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |\n * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |\n * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |\n * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |\n * |                                 | ii      | 01, 02, ..., 07                   | 7     |\n * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |\n * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |\n * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |\n * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |\n * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |\n * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |\n * |                                 | ee      | 02, 03, ..., 01                   |       |\n * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |\n * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | eeeee   | M, T, W, T, F, S, S               |       |\n * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |\n * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |\n * |                                 | cc      | 02, 03, ..., 01                   |       |\n * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |\n * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |\n * |                                 | ccccc   | M, T, W, T, F, S, S               |       |\n * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |\n * | AM, PM                          | a..aaa  | AM, PM                            |       |\n * |                                 | aaaa    | a.m., p.m.                        | 2     |\n * |                                 | aaaaa   | a, p                              |       |\n * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |\n * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |\n * |                                 | bbbbb   | a, p, n, mi                       |       |\n * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |\n * |                                 | BBBB    | at night, in the morning, ...     | 2     |\n * |                                 | BBBBB   | at night, in the morning, ...     |       |\n * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |\n * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |\n * |                                 | hh      | 01, 02, ..., 11, 12               |       |\n * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |\n * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |\n * |                                 | HH      | 00, 01, 02, ..., 23               |       |\n * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |\n * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |\n * |                                 | KK      | 01, 02, ..., 11, 00               |       |\n * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |\n * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |\n * |                                 | kk      | 24, 01, 02, ..., 23               |       |\n * | Minute                          | m       | 0, 1, ..., 59                     |       |\n * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |\n * |                                 | mm      | 00, 01, ..., 59                   |       |\n * | Second                          | s       | 0, 1, ..., 59                     |       |\n * |                                 | so      | 0th, 1st, ..., 59th               | 7     |\n * |                                 | ss      | 00, 01, ..., 59                   |       |\n * | Fraction of second              | S       | 0, 1, ..., 9                      |       |\n * |                                 | SS      | 00, 01, ..., 99                   |       |\n * |                                 | SSS     | 000, 0001, ..., 999               |       |\n * |                                 | SSSS    | ...                               | 3     |\n * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |\n * |                                 | XX      | -0800, +0530, Z                   |       |\n * |                                 | XXX     | -08:00, +05:30, Z                 |       |\n * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |\n * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |\n * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |\n * |                                 | xx      | -0800, +0530, +0000               |       |\n * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |\n * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |\n * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |\n * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |\n * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |\n * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |\n * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |\n * | Seconds timestamp               | t       | 512969520                         | 7     |\n * |                                 | tt      | ...                               | 3,7   |\n * | Milliseconds timestamp          | T       | 512969520900                      | 7     |\n * |                                 | TT      | ...                               | 3,7   |\n * | Long localized date             | P       | 05/29/1453                        | 7     |\n * |                                 | PP      | May 29, 1453                      | 7     |\n * |                                 | PPP     | May 29th, 1453                    | 7     |\n * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |\n * | Long localized time             | p       | 12:00 AM                          | 7     |\n * |                                 | pp      | 12:00:00 AM                       | 7     |\n * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |\n * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |\n * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |\n * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |\n * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |\n * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |\n * Notes:\n * 1. \"Formatting\" units (e.g. formatting quarter) in the default en-US locale\n *    are the same as \"stand-alone\" units, but are different in some languages.\n *    \"Formatting\" units are declined according to the rules of the language\n *    in the context of a date. \"Stand-alone\" units are always nominative singular:\n *\n *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`\n *\n *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`\n *\n * 2. Any sequence of the identical letters is a pattern, unless it is escaped by\n *    the single quote characters (see below).\n *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n *    the output will be the same as default pattern for this unit, usually\n *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n *    are marked with \"2\" in the last column of the table.\n *\n *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`\n *\n *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`\n *\n * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).\n *    The output will be padded with zeros to match the length of the pattern.\n *\n *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`\n *\n * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.\n *    These tokens represent the shortest form of the quarter.\n *\n * 5. The main difference between `y` and `u` patterns are B.C. years:\n *\n *    | Year | `y` | `u` |\n *    |------|-----|-----|\n *    | AC 1 |   1 |   1 |\n *    | BC 1 |   1 |   0 |\n *    | BC 2 |   2 |  -1 |\n *\n *    Also `yy` always returns the last two digits of a year,\n *    while `uu` pads single digit years to 2 characters and returns other years unchanged:\n *\n *    | Year | `yy` | `uu` |\n *    |------|------|------|\n *    | 1    |   01 |   01 |\n *    | 14   |   14 |   14 |\n *    | 376  |   76 |  376 |\n *    | 1453 |   53 | 1453 |\n *\n *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),\n *    except local week-numbering years are dependent on `options.weekStartsOn`\n *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}\n *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).\n *\n * 6. Specific non-location timezones are currently unavailable in `date-fns`,\n *    so right now these tokens fall back to GMT timezones.\n *\n * 7. These patterns are not in the Unicode Technical Standard #35:\n *    - `i`: ISO day of week\n *    - `I`: ISO week of year\n *    - `R`: ISO week-numbering year\n *    - `t`: seconds timestamp\n *    - `T`: milliseconds timestamp\n *    - `o`: ordinal number modifier\n *    - `P`: long localized date\n *    - `p`: long localized time\n *\n * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.\n *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr\n *\n * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.\n *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * - The second argument is now required for the sake of explicitness.\n *\n *   ```javascript\n *   // Before v2.0.0\n *   format(new Date(2016, 0, 1))\n *\n *   // v2.0.0 onward\n *   format(new Date(2016, 0, 1), \"yyyy-MM-dd'T'HH:mm:ss.SSSxxx\")\n *   ```\n *\n * - New format string API for `format` function\n *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).\n *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.\n *\n * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.\n *\n * @param {Date|Number} date - the original date\n * @param {String} format - the string of tokens\n * @param {Object} [options] - an object with options.\n * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}\n * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)\n * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is\n * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;\n *   see: https://git.io/fxCyr\n * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;\n *   see: https://git.io/fxCyr\n * @returns {String} the formatted date string\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `date` must not be Invalid Date\n * @throws {RangeError} `options.locale` must contain `localize` property\n * @throws {RangeError} `options.locale` must contain `formatLong` property\n * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6\n * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7\n * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr\n * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr\n * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr\n * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr\n * @throws {RangeError} format string contains an unescaped latin alphabet character\n *\n * @example\n * // Represent 11 February 2014 in middle-endian format:\n * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')\n * //=> '02/11/2014'\n *\n * @example\n * // Represent 2 July 2014 in Esperanto:\n * import { eoLocale } from 'date-fns/locale/eo'\n * var result = format(new Date(2014, 6, 2), \"do 'de' MMMM yyyy\", {\n *   locale: eoLocale\n * })\n * //=> '2-a de julio 2014'\n *\n * @example\n * // Escape string by single quote characters:\n * var result = format(new Date(2014, 6, 2, 15), \"h 'o''clock'\")\n * //=> \"3 o'clock\"\n */\n\nexport default function format(dirtyDate, dirtyFormatStr, dirtyOptions) {\n  requiredArgs(2, arguments);\n  var formatStr = String(dirtyFormatStr);\n  var options = dirtyOptions || {};\n  var locale = options.locale || defaultLocale;\n  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;\n  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);\n  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN\n\n  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {\n    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');\n  }\n\n  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;\n  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);\n  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN\n\n  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {\n    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');\n  }\n\n  if (!locale.localize) {\n    throw new RangeError('locale must contain localize property');\n  }\n\n  if (!locale.formatLong) {\n    throw new RangeError('locale must contain formatLong property');\n  }\n\n  var originalDate = toDate(dirtyDate);\n\n  if (!isValid(originalDate)) {\n    throw new RangeError('Invalid time value');\n  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.\n  // This ensures that when UTC functions will be implemented, locales will be compatible with them.\n  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376\n\n\n  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);\n  var utcDate = subMilliseconds(originalDate, timezoneOffset);\n  var formatterOptions = {\n    firstWeekContainsDate: firstWeekContainsDate,\n    weekStartsOn: weekStartsOn,\n    locale: locale,\n    _originalDate: originalDate\n  };\n  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {\n    var firstCharacter = substring[0];\n\n    if (firstCharacter === 'p' || firstCharacter === 'P') {\n      var longFormatter = longFormatters[firstCharacter];\n      return longFormatter(substring, locale.formatLong, formatterOptions);\n    }\n\n    return substring;\n  }).join('').match(formattingTokensRegExp).map(function (substring) {\n    // Replace two single quote characters with one single quote character\n    if (substring === \"''\") {\n      return \"'\";\n    }\n\n    var firstCharacter = substring[0];\n\n    if (firstCharacter === \"'\") {\n      return cleanEscapedString(substring);\n    }\n\n    var formatter = formatters[firstCharacter];\n\n    if (formatter) {\n      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {\n        throwProtectedError(substring, dirtyFormatStr, dirtyDate);\n      }\n\n      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {\n        throwProtectedError(substring, dirtyFormatStr, dirtyDate);\n      }\n\n      return formatter(utcDate, substring, locale.localize, formatterOptions);\n    }\n\n    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {\n      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');\n    }\n\n    return substring;\n  }).join('');\n  return result;\n}\n\nfunction cleanEscapedString(input) {\n  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, \"'\");\n}","import { Values } from 'SVConstants'\nimport { getStore } from 'SVStore'\n\nconst { SESSION_BOOKING_STATES } = Values\n\n/**\n * gets the booking state of the session\n * @param {import('SVModels/session').Session} session\n * @returns {SESSION_BOOKING_STATES}\n */\nexport const getBookingState = session => {\n  const { items } = getStore()?.getState()\n  const attendees = items?.attendees || []\n\n  if (session.allowBooking) {\n    // ON_WAITING_LIST - Any session where the session identifier is included in the waitingListSessions array for any attendee\n    // ON_WAITING_LIST takes precedence over SELECTED\n    const inAttendeeWaitingList = attendees.some(attendee =>\n      attendee.waitingListSessions?.some(id => id === session.identifier)\n    )\n\n    // Custom identifier to flag that booking has been stopped for that session\n    // Will need to update when Events-Force gives us the real value\n    // If attendees are on the waiting list, but booking is stopped, then return fully booked\n    // Otherwise return the on waiting list state\n    if (inAttendeeWaitingList)\n      return session.bookingStopped\n        ? SESSION_BOOKING_STATES.FULLY_BOOKED\n        : SESSION_BOOKING_STATES.ON_WAITING_LIST\n\n    // SELECTED - Any session where the session identifier is included in the bookedSessions array for any attendee\n    const inAttendeeBookedSessions = attendees.some(attendee =>\n      attendee.bookedSessions?.some(id => id === session.identifier)\n    )\n    if (inAttendeeBookedSessions) return SESSION_BOOKING_STATES.SELECTED\n\n    // Custom identifier to flag that booking has been stopped for that session\n    // Will need to update when Events-Force gives us the real value\n    if (session.bookingStopped) return SESSION_BOOKING_STATES.FULLY_BOOKED\n\n    /**\n     * SELECT - Any session where allowBooking is true and is either unlimited or has remaining places\n     * WAITING_LIST - Any session where capacity is limited, has no remaining places and has a waiting list\n     */\n    return session.capacity?.isUnlimited ||\n      session.capacity?.remainingPlaces > 0\n      ? SESSION_BOOKING_STATES.SELECT\n      : session.capacity?.isWaitingListAvailable\n        ? SESSION_BOOKING_STATES.WAITING_LIST\n        : SESSION_BOOKING_STATES.FULLY_BOOKED\n  }\n\n  return SESSION_BOOKING_STATES.READ_ONLY\n}\n","import { checkCall, omitKeys } from '@keg-hub/jsutils'\nimport { useStyle } from '@keg-hub/re-theme'\nimport { EvfLoading } from 'SVComponents/loading/evfLoading'\nimport React, { useMemo, useContext, useCallback } from 'react'\nimport { renderFromType, View, Text } from '@keg-hub/keg-components'\nimport { ComponentsContext } from 'SVContexts/components/componentsContext'\n\n/**\n * Processing\n * @param {object} props\n * @param {object} props.styles\n * @param {string=} props.text\n */\nconst Processing = props => {\n  const { pendingStyles, styles, text = 'Processing' } = props\n\n  const processStyles = useStyle(styles, pendingStyles)\n\n  return (\n    <View\n      className={'ef-button-text-main'}\n      style={styles.main}\n    >\n      <EvfLoading\n        color={processStyles?.icon?.color}\n        size={processStyles?.icon?.size}\n      />\n      <Text\n        className={'ef-button-text'}\n        style={[processStyles.content]}\n      >\n        { text }\n      </Text>\n    </View>\n  )\n}\n\n/**\n * Render the children based on the passed in type\n * @param {Object} props\n * @param {Object|function|string} props.children - Child content to render\n * @param {Object} props.styles - Custom styles for the children components\n * @param {boolean} props.selectable - Should the text be selectable\n * @param {boolean} props.isProcessing - Is the button in a processing state\n *\n * @returns {Object} - Merged Evf button styles\n */\nconst RenderChildren = React.memo(props => {\n  const {\n    children,\n    styles,\n    pendingStyles,\n    selectable = false,\n    isProcessing = false,\n  } = props\n\n  const contentStyles = useStyle(`button.contained.default`, styles?.button)\n\n  const content = isProcessing\n    ? buttonProps => (\n        <Processing\n          {...buttonProps}\n          pendingStyles={pendingStyles}\n          styles={styles?.processing}\n        />\n      )\n    : children\n\n  const contentProps = useMemo(() => {\n    const style = omitKeys(contentStyles?.default?.content, [\n      'color',\n      'transitionProperty',\n      'transitionDuration',\n      'transitionTimingFunction',\n    ])\n\n    return {\n      style,\n      selectable,\n      className: `ef-button-text`,\n    }\n  }, [ content, contentStyles, selectable ])\n\n  return renderFromType(content, contentProps, Text)\n})\n\n/**\n * EvfButton\n * @param {object} props\n * @param {object} props.styles\n * @param {object} props.onClick\n * @param {('default'|'primary')} props.type - button type. defaults to 'default'\n * @param {string} props.text - text to display on button\n * @param {boolean} props.isProcessing - to display processing content\n */\nexport const EvfButton = props => {\n  const {\n    buttonType,\n    children,\n    disabled,\n    isProcessing,\n    onClick,\n    styles,\n    text,\n    ...childProps\n  } = props\n\n  const { ButtonComponent } = useContext(ComponentsContext)\n  const btnStyles = useStyle(`button.evfButton`, styles)\n\n  // Wrap the onClick, so we can catch the event\n  // Then stop it from propagating to the parent elements\n  const onBtnClick = useCallback(\n    event => {\n      event.stopPropagation()\n      checkCall(onClick, event)\n    },\n    [onClick]\n  )\n\n  // EVF will only accept these props for their button component\n  // The buttonType should be one of selectSession | \"modalPrimary\" | \"modalSecondary\"\n  return (\n    <ButtonComponent\n      disabled={Boolean(disabled || isProcessing)}\n      buttonType={buttonType}\n      onClick={onBtnClick}\n    >\n      <RenderChildren\n        {...childProps}\n        styles={btnStyles}\n        children={children || text}\n        isProcessing={isProcessing}\n      />\n    </ButtonComponent>\n  )\n}\n","import { useMemo } from 'react'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\nimport { validate, isStr } from '@keg-hub/jsutils'\n\n/**\n * Helper for `useRestrictedAttendeeIds`. Builds an\n * `isBookable` function returned by that hook, with validation\n * @param {Array<string>?} restrictedIdsForSession\n */\nconst getIsBookable = restrictedIdsForSession => {\n  return attendeeId => {\n    const [valid] = validate({ attendeeId }, { attendeeId: isStr })\n    if (!valid) return false\n    return (\n      restrictedIdsForSession && !restrictedIdsForSession.includes(attendeeId)\n    )\n  }\n}\n\n/**\n * Returns an object with the following properties:\n *  - restrictedAttendeeIds: map of restricted attendee ids by session\n *  - restrictedAttendeeIdsForSession: the attendee ids for this sessionId\n *  - isBookable: a function indicating an attendee (id) can book a given session.\n *                If it returns false, that attendee with that id is restricted from booking.\n * @param {string?} sessionId - id of session - only required if you want helper fn isBookable\n * @return {Object} restricted data\n */\nexport const useRestrictedAttendeeIds = sessionId => {\n  const restrictedAttendeeIds = useStoreItems('restrictedAttendeeIds')\n  const restrictedIdsForSession = restrictedAttendeeIds?.[sessionId]\n  return useMemo(\n    () => ({\n      restrictedAttendeeIds,\n      restrictedIdsForSession,\n      isBookable: getIsBookable(restrictedIdsForSession),\n    }),\n    [ restrictedAttendeeIds, sessionId ]\n  )\n}\n","import { useMemo } from 'react'\nimport { noOpObj, noPropArr, exists } from '@keg-hub/jsutils'\nimport { getTimeFromDate } from 'SVUtils/dateTime'\n\n/**\n * Creates an EPOCH time based on the passed in time argument\n * @param {string} time - Time of the day to create the EPOCH time for\n *\n * @returns {number} - EPOCH time for the passed in time\n */\nconst getEpochTime = time => {\n  return Date.parse(`1970/01/01 ${time.replace(/(AM)|(PM)/, '')}`)\n}\n\n/**\n * Gets the EPOCH time for a sessions start and end times\n * @param {Object} session - current session to book attendees with\n *\n * @returns {Object} - Contains the sessions start and end times as EPOCH\n */\nconst parseSessionTimes = ({ startDateTimeLocal, endDateTimeLocal }) => {\n  return {\n    startBlock: getEpochTime(getTimeFromDate(startDateTimeLocal)),\n    endBlock: getEpochTime(getTimeFromDate(endDateTimeLocal)),\n  }\n}\n\n/**\n * Checks if the timeBlock is at or between the start and end blocks\n * @param {string} startEpoch - The start of the current session\n * @param {string} endEpoch - The end of the current session\n * @param {string} checkStartEpoch - The start of the session to be checked\n * @param {string} checkEndEpoch - The end of the session to be checked\n *\n * @returns {boolean} - Is the timeBlock time after the endBlock time\n */\nconst timeConflict = (startEpoch, endEpoch, checkStartEpoch, checkEndEpoch) => {\n  return (\n    startEpoch &&\n    endEpoch &&\n    checkStartEpoch &&\n    checkEndEpoch &&\n    Boolean(startEpoch < checkEndEpoch && checkStartEpoch < endEpoch)\n  )\n}\n\n/**\n * Gets a list of sessions relative to the start and end time of the passed in session Id\n * @param {Object} daySessions - All sessions for the day\n * @param {string} startEpoch - The start of the current session\n * @param {string} endEpoch - The end of the session to be checked\n * @param {string} sessionId - Id of the current session\n *\n * @returns {Array} - Group of sessions id's relative to the passed in start and end block times\n */\nconst getRelativeSessions = (\n  daySessions,\n  startEpoch,\n  endEpoch,\n  sessionId,\n  sessionDay\n) => {\n  return (\n    (daySessions &&\n      daySessions.length &&\n      daySessions.reduce((relativeSessions, { sessions, timeBlock }) => {\n        sessions &&\n          sessions.length &&\n          sessions.map(session => {\n            if (\n              (exists(sessionDay) && session.dayNumber !== sessionDay) ||\n              session.identifier === sessionId\n            )\n              return\n\n            const {\n              startBlock: checkStartEpoch,\n              endBlock: checkEndEpoch,\n            } = parseSessionTimes(session)\n\n            return (\n              timeConflict(\n                startEpoch,\n                endEpoch,\n                checkStartEpoch,\n                checkEndEpoch\n              ) && relativeSessions.push(session.identifier)\n            )\n          })\n\n        return relativeSessions\n      }, [])) ||\n    noPropArr\n  )\n}\n\n/**\n * Checks if a time conflict exists\n * @param {Object} booked - Currently booked sessions for an attendee (attendee.bookedSessions)\n * @param {Array} sessionIds - Group of sessions id's found in the getRelativeSessions method\n *\n * @returns {string|boolean} - Conflicting session if a conflict exists or false it no conflict exists\n */\nconst hasTimeConflict = (booked, sessionIds) => {\n  return (\n    Boolean(booked) &&\n    Boolean(booked.length) &&\n    booked.reduce((timeConflict, bookedId) => {\n      const bookedIdStr = bookedId?.toString()\n      return timeConflict || (sessionIds.includes(bookedIdStr) && bookedIdStr)\n    }, false)\n  )\n}\n\n/**\n * Loops over all attendees, and checks for time conflicts between currently booked session and relative sessions\n * @param {Array} attendees - Who should be checked for time-conflicts\n * @param {Array} relativeSessions - Group of sessions id's found in the getRelativeSessions method\n *\n * @returns {Object} - Conflicting Object containing attendees ids mapped to conflicting sessions\n */\nconst getTimeConflicts = (attendees, relativeSessions) => {\n  return attendees.reduce((conflicts, attendee) => {\n    const conflictId = hasTimeConflict(\n      attendee.bookedSessions,\n      relativeSessions\n    )\n\n    conflictId !== false &&\n      (conflicts[attendee.bookedTicketIdentifier] = conflictId)\n\n    return conflicts\n  }, {})\n}\n\n/**\n * Looks for time-conflicts between the passed in session and an array of attendees\n * @param {Object} session - current session to book attendees with\n * @param {Array} attendees - Who should be checked for time-conflicts\n * @param {Object} daySessions - All sessions for the day\n *\n * @returns {Object|boolean} - Contains key value pair of attendee.bookedTicketIdentifier as the key and conflicting session id as the value\n *                             Return false if no conflicts are found\n */\nexport const useBookingTimeConflicts = (session, attendees, daySessions) => {\n  const { identifier: sessionId, dayNumber: sessionDay } = session\n  const { startBlock, endBlock } = parseSessionTimes(session)\n\n  return useMemo(() => {\n    const conflicts =\n      !sessionId || !attendees.length\n        ? noOpObj\n        : getTimeConflicts(\n          attendees,\n          getRelativeSessions(\n            daySessions,\n            startBlock,\n            endBlock,\n            sessionId,\n            sessionDay\n          )\n        )\n\n    return Object.keys(conflicts).length ? conflicts : false\n  }, [ sessionId, startBlock, endBlock, daySessions, attendees ])\n}\n","import { useCallback } from 'react'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\nimport { useRestrictedAttendeeIds } from 'SVHooks/booking/useRestrictedAttendeeIds'\nimport { useBookingTimeConflicts } from 'SVHooks/booking/useBookingTimeConflicts'\nimport { useIsRegisteredForDayCallback } from './useIsRegisteredForDayCallback'\nimport { Values } from 'SVConstants'\nimport { validate, isObj, isArr } from '@keg-hub/jsutils'\n\nconst { CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * Helper for `useIsAttendeeDisabledCallback` that checks for time conflicts\n * @param {import('SVModels/Session').Session} session\n * @param {Array<import('SVModels/Attendee').Attendee>} attendees\n * @returns {Function?} a callback of form (attendeeId) -> Boolean, which returns\n * true if the attendee is timeblocked against `session`\n */\nconst useIsTimeBlockedCallback = (session, attendees) => {\n  const agendaSettings = useStoreItems(\n    `${CATEGORIES.SETTINGS}.${SUB_CATEGORIES.AGENDA_SETTINGS}`\n  )\n  const agendaSessions = useStoreItems(CATEGORIES.AGENDA_SESSIONS)\n  const timeConflicts = useBookingTimeConflicts(\n    session,\n    attendees,\n    agendaSessions[agendaSettings?.activeDayNumber ?? 1]\n  )\n  return useCallback(attendeeId => Boolean(timeConflicts?.[attendeeId]), [\n    timeConflicts,\n  ])\n}\n\n/**\n * Helper for determining if an attendee is restricted from booking a session\n *  - checks both the restricted attendee list and searches for time conflicts with other sessions\n * @param {import('SVModels/Session').Session} session\n * @param {Array<import('SVModels/Attendee').Attendee>} attendees\n * @returns {Function?} a callback of form (attendeeId) -> Boolean, which returns\n * true if the attendee is disabled (cannot be booked or selected in the group booking modal)\n */\nexport const useIsAttendeeDisabledCallback = (session, attendees) => {\n  const [valid] = validate(\n    { session, attendees },\n    { session: isObj, attendees: isArr }\n  )\n  if (!valid) return null\n\n  const { isBookable } = useRestrictedAttendeeIds(session?.identifier)\n  const isTimeBlocked = useIsTimeBlockedCallback(session, attendees)\n  const isRegisteredForDay = useIsRegisteredForDayCallback(\n    session?.dayNumber,\n    attendees\n  )\n\n  return useCallback(\n    attendeeId =>\n      isTimeBlocked(attendeeId) ||\n      !isBookable(attendeeId) ||\n      !isRegisteredForDay(attendeeId),\n    [ isBookable, isTimeBlocked, isRegisteredForDay ]\n  )\n}\n","import React, { useCallback } from 'react'\nimport { AttendeeCheckboxItem } from './attendeeCheckboxItem'\nimport { Values } from 'SVConstants'\nconst { CATEGORIES } = Values\nimport { useIsAttendeeDisabledCallback } from 'SVHooks/models/attendees/useIsAttendeeDisabledCallback'\nimport { useGroupBookingContext } from 'SVContexts/booking/groupBookingContext'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\n\n/**\n * Gets computed values about the state of all checkboxees in the attendee list\n * @param {import('SVModels/session').Session} session\n * @param {number} groupBookingCapacity - current capacity of the session\n * @returns {Object} { enableCheck }\n */\nconst useCheckboxState = (session, groupBookingCapacity) => {\n  return {\n    enableCheck:\n      session?.capacity?.isUnlimited ||\n      session?.capacity?.isWaitingListAvailable ||\n      groupBookingCapacity > 0,\n  }\n}\n\n/**\n * List of attendees for a group booking section\n * @param {Object} props\n * @param {Array<import('SVModels/attendee').Attendee>} props.attendees - attendee list for current section\n * @param {Object} props.itemStyles\n * @param {Object} props.sectionStyles\n * @param {string} props.attendeeClassname - class name for attendee item\n */\nexport const AttendeeBookingList = ({\n  attendees,\n  itemStyles,\n  sectionStyles,\n  attendeeClassName,\n}) => {\n  const { state, actions } = useGroupBookingContext()\n\n  const { enableCheck } = useCheckboxState(state.session, state.capacity)\n  const isAttendeeDisabled = useIsAttendeeDisabledCallback(\n    state.session,\n    attendees\n  )\n  const pendingSession = useStoreItems(CATEGORIES.PENDING_SESSION)\n  const isDisabledOrPending = useCallback(\n    id => pendingSession?.identifier || isAttendeeDisabled(id)\n  )\n\n  return attendees?.map(({ bookedTicketIdentifier: attendeeId, name }) => {\n    const isBooking = state.current?.bookingList?.includes(attendeeId)\n    const isWaiting = state.current?.waitingList?.includes(attendeeId)\n\n    return (\n      <AttendeeCheckboxItem\n        key={attendeeId}\n        id={attendeeId}\n        name={name}\n        textClassName={attendeeClassName}\n        onAttendeeSelected={actions.updateSessionBooking}\n        isWaiting={isWaiting}\n        sectionStyles={sectionStyles}\n        itemStyles={itemStyles}\n        isAttendeeDisabled={isDisabledOrPending}\n        enableCheck={enableCheck}\n        checked={isBooking || isWaiting}\n      />\n    )\n  })\n}\n","import React, { useMemo } from 'react'\nimport { Text } from '@keg-hub/keg-components'\nimport { AttendeeBookingList } from './attendeeBookingList'\nimport { CheckGroup } from '@keg-hub/keg-components'\nimport { useStyle } from '@keg-hub/re-theme'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\n\n/**\n * Gets the list of Attendee objects for the current section,\n * the ones that have the same ids as in the list\n * of attendeeIdsForSection\n * @param {Array<string>} attendeeIds\n * @returns {Array<import('SVModels/attendee').Attendee>}  section attendees\n */\nconst useSectionAttendees = attendeeIdsForSection => {\n  const attendees = useStoreItems('attendees')\n  return useMemo(\n    () =>\n      attendees.filter(({ bookedTicketIdentifier }) =>\n        attendeeIdsForSection?.includes(bookedTicketIdentifier)\n      ),\n    [ attendees, attendeeIdsForSection ]\n  )\n}\n\n/**\n * A section in the group booker, containing a header and a list of checkable attendees\n *\n * @param {Object} props\n * @param {string} props.className - class name for root checkgroup\n * @param {Object} props.styles\n * @param {string} props.name - header title\n * @param {Array<string>} props.attendeeIds - ids of attendees to display in section\n * @param {string} props.headerClassName - class name for header of group\n * @param {string} props.attendeeClassName - class name for attendee item\n */\nexport const GroupBookingSection = ({\n  className,\n  styles,\n  name,\n  attendeeIds,\n  headerClassName,\n  attendeeClassName,\n}) => {\n  const sectionStyles = useStyle('groupBookingSection', styles)\n  const itemStyles = useStyle(\n    'form.checkbox.close',\n    sectionStyles?.content?.item\n  )\n  const attendeesForSection = useSectionAttendees(attendeeIds)\n\n  return (\n    <CheckGroup\n      className={className}\n      headerClassName={headerClassName}\n      styles={sectionStyles}\n      title={name}\n    >\n      <AttendeeBookingList\n        attendees={attendeesForSection}\n        itemStyles={itemStyles}\n        attendeeClassName={attendeeClassName}\n        sectionStyles={sectionStyles}\n      />\n      { !attendeesForSection?.length && (\n        <Text>No attendees for this category</Text>\n      ) }\n    </CheckGroup>\n  )\n}\n","import React from 'react'\nimport { ScrollView } from '@keg-hub/keg-components'\nimport { GroupBookingSection } from './groupBookingSection'\nimport { useStyle } from '@keg-hub/re-theme'\nimport { useTicketsForBooking } from 'SVHooks/models/useTicketsForBooking'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\n\nconst emptyArr = []\n\n/**\n * A list of group booking sections, in a scroll view\n * @param {Object} props\n * @param {Object} props.styles\n */\nexport const GroupBookingOptions = props => {\n  const { className, styles } = props\n\n  const viewStyles = useStyle('groupBookingOptions.main', styles?.main)\n\n  // sort tickets by display order and filter out invalid ones\n  const tickets = useStoreItems('tickets')\n  const attendeesByTicket = useStoreItems('attendeesByTicket')\n  const sortedTickets = useTicketsForBooking(tickets, attendeesByTicket)\n\n  return (\n    <ScrollView\n      className={className}\n      style={viewStyles}\n    >\n      { sortedTickets.map(ticket => (\n        <GroupBookingSection\n          headerClassName='ef-modal-body-highlight'\n          attendeeClassName='ef-modal-sub-header'\n          styles={styles?.section}\n          key={ticket.identifier}\n          name={ticket.name}\n          attendeeIds={attendeesByTicket[ticket.identifier] || emptyArr}\n        />\n      )) }\n    </ScrollView>\n  )\n}\n","import { logData } from '@keg-hub/jsutils'\n\nlet KegEventEmitter\n\n/**\n * Stores events based on event names, which can then be called at another time in a different location\n *\n * @export\n * @class EventEmitter\n */\nexport class EventEmitter {\n  listeners = {}\n\n  on = (event, cb) => {\n    if (!this.listeners[event]) this.listeners[event] = new Set()\n\n    if (this.listeners[event].has(cb))\n      return logData(\n        `Listener already exists for router event: \\`${event}\\``,\n        `error`\n      )\n\n    this.listeners[event].add(cb)\n    return this\n  }\n\n  emit = (event, ...data) => {\n    const listeners = this.listeners[event]\n    if (!listeners || !listeners.size) return false\n\n    listeners.forEach(cb => cb(...data))\n\n    return true\n  }\n\n  off = (event, cb) => {\n    this.listeners[event].delete(cb)\n    return this\n  }\n}\n\n/**\n * Gets the App Event Emitter, if one does not exist it creates it\n *\n * @returns {EventEmitter|Object} - Instance of an EventEmitter\n */\nexport const getEventEmitter = () => {\n  KegEventEmitter = KegEventEmitter || new EventEmitter()\n\n  return KegEventEmitter\n}\n","import { setActiveModal } from './setActiveModal'\nimport { Modal } from 'SVModels/modal'\nimport { validate, isStr } from '@keg-hub/jsutils'\nimport { Values } from 'SVConstants'\nconst { CATEGORIES } = Values\n\n/**\n * Validates `showAlertModal` arguments\n * @param {string} title\n * @param {string} message\n */\nconst isValidInput = (message, title) => {\n  const [valid] = validate({ title, message }, { $default: isStr })\n  return valid\n}\n\nconst alertModalType = CATEGORIES.ALERT.toLowerCase()\n\n/**\n * Action for settings the active modal to an alert modal\n * @param {string} title - alert title\n * @param {string} message - alert message\n */\nexport const showAlertModal = (message, title = 'Error') => {\n  if (!isValidInput(title, message)) return\n\n  const modal = new Modal({\n    type: alertModalType,\n    data: {\n      title,\n      message,\n    },\n  })\n\n  setActiveModal(modal)\n}\n","import React from 'react'\nimport { Text, View } from '@keg-hub/keg-components'\nimport { EvfButton } from 'SVComponents/button/evfButton'\nimport { noOpObj, validate, isObj } from '@keg-hub/jsutils'\nimport { GroupBookingOptions } from 'SVComponents/booking/groupBookingOptions'\nimport { Values } from 'SVConstants'\nimport { useBookSessionCallback } from 'SVHooks/booking/useBookSessionCallback'\nimport { useGroupBookingContext } from 'SVContexts/booking/groupBookingContext'\nimport { isBookingModified } from 'SVContexts/booking/utils/isBookingModified'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\nimport PropTypes from 'prop-types'\n\nconst { CATEGORIES, BUTTON_TYPES } = Values\n\n/**\n * The root group booking component. Makes use of the GroupBookingContext.\n * @param {Object} props\n * @param {Object?} props.styles\n * @param {import('SVModels/session').Session} props.session - current session\n */\nexport const GroupBookerBody = ({ styles, session }) => {\n  const [valid] = validate({ session }, { session: isObj })\n  if (!valid) return null\n\n  const topSectionStyles = styles?.content?.topSection || noOpObj\n  const middleSectionStyles = styles?.content?.middleSection || noOpObj\n\n  return (\n    <View\n      className={`ef-modal-group-body`}\n      style={styles.main}\n    >\n      <TopSection styles={topSectionStyles} />\n\n      <GroupBookingOptions\n        className={`ef-modal-group-section-middle`}\n        styles={middleSectionStyles}\n      />\n    </View>\n  )\n}\nGroupBookerBody.propTypes = {\n  styles: PropTypes.object,\n  session: PropTypes.object,\n}\n\n/**\n * Top section of the group booker - contains the instruction text and spots remaining\n * @param {object} props\n * @param {object} props.styles\n */\nconst TopSection = ({ styles }) => {\n  // use correct wording depending on number of spots remaining\n  const { state } = useGroupBookingContext()\n  const showRequireSymbol = !isBookingModified(state)\n  const placeText = state.capacity === 1 ? 'place' : 'places'\n  return (\n    <View\n      className={`ef-modal-group-section-top`}\n      style={styles?.main}\n    >\n      <Text\n        className={`ef-modal-body-header`}\n        style={styles?.content?.instructionText}\n      >\n        Select sessions for your group:{ ' ' }\n        { showRequireSymbol && (\n          <Text style={styles?.content?.instructionAsterisk}>*</Text>\n        ) }\n      </Text>\n      { state.showCapacity && (\n        <Text\n          className={`ef-modal-body-highlight`}\n          style={styles?.content?.infoText}\n        >\n          { `${state.capacity} ${placeText} remaining` }\n        </Text>\n      ) }\n    </View>\n  )\n}\n\n/**\n * Footer section of group booker\n * @param {object} props\n * @param {object} props.styles\n * @param {boolean} props.isLoading - if the submit button should show loading spinner\n * @param {Function} props.onCancelPress\n */\nexport const GroupBookerFooter = ({ styles = noOpObj, onCancelPress }) => {\n  const { state } = useGroupBookingContext()\n  const { session, current, modified } = state\n  const bookSession = useBookSessionCallback(\n    session,\n    modified.bookingList && current.bookingList,\n    modified.waitingList && current.waitingList\n  )\n  const pendingSession = useStoreItems(CATEGORIES.PENDING_SESSION)\n  const submitDisabled = pendingSession?.identifier || !isBookingModified(state)\n\n  return (\n    <View\n      className={`ef-modal-group-section-bottom`}\n      style={styles.main}\n    >\n      <View\n        className={'evf-modal-cancel-wrapper'}\n        style={styles.content?.cancelButton?.container}\n      >\n        <EvfButton\n          buttonType={BUTTON_TYPES.MODAL_SECONDARY}\n          className='ef-cancel-session-button'\n          type={'default'}\n          styles={styles.content?.cancelButton}\n          text={'CANCEL'}\n          onClick={onCancelPress}\n        />\n      </View>\n      <EvfButton\n        buttonType={BUTTON_TYPES.MODAL_PRIMARY}\n        className='ef-select-session-button'\n        isProcessing={pendingSession?.identifier}\n        type={'primary'}\n        styles={styles.content?.bookButton}\n        text={'BOOK SELECTED'}\n        disabled={submitDisabled}\n        onClick={bookSession}\n      />\n    </View>\n  )\n}\n","import { useMemo } from 'react'\nimport { getExistingWaitIds } from 'SVUtils/booking/getExistingWaitIds'\nimport { getExistingBookIds } from 'SVUtils/booking/getExistingBookIds'\nimport { useIsAttendeeDisabledCallback } from 'SVHooks/models/attendees/useIsAttendeeDisabledCallback'\n\n/**\n * @param {boolean} initialCapacityExceedsNeed\n * @param {Array<string>} initialWaitIds - list of attendee ids on wait list\n * @param {Array<string>} initialBookedIds - list of attendee ids on book list\n * @return {boolean} true if the initial booked list should preselect all the attendees\n */\nconst shouldPreselectAttendees = (\n  initialCapacityExceedsNeed,\n  initialWaitIds,\n  initialBookedIds\n) => {\n  return (\n    initialCapacityExceedsNeed &&\n    !initialWaitIds?.length &&\n    !initialBookedIds?.length\n  )\n}\n\n/**\n * Builds the initial list of booked attendee ids for the session\n * @param {Object} session - session object\n * @param {Array<import('SVModels/Attendee').Attendee>} attendees - full list of attendees\n * @param {Array<string>} initialWaitIds - list of ids on the initial waiting list\n * @param {Function} isAttendeeDisabled - cb of form: attendeeId => true/false if bookable/waitListable to the session\n * @param {boolean} initialCapacityExceedsNeed - true if the initial capacity exceeds the potential\n * @return {Array<string>} initial booking ids\n */\nconst getInitialBookingIds = (\n  existingBookIds,\n  attendees,\n  isAttendeeDisabled,\n  shouldPreselect\n) => {\n  // if nobody is on the waiting list, and the capacity of session is greater than the number of attendees,\n  // include all the attendees that are bookable\n  if (shouldPreselect)\n    return attendees.reduce((ids, nextAttendee) => {\n      if (isAttendeeDisabled(nextAttendee.bookedTicketIdentifier)) return ids\n      ids.push(nextAttendee.bookedTicketIdentifier)\n      return ids\n    }, [])\n\n  // otherwise just get the existing list of booked ids, removing any ones that aren't bookable\n  return existingBookIds\n}\n\n/**\n * Hook to acquire the **initial** booking and waiting lists for a session for the group booking modal\n * @param {import('SVModels/session').Session} session - session to get the booking & waiting lists for\n * @param {Array<import('SVModels/attendee').Attendee>} attendees - full list of attendees\n * @param {boolean} initialCapacityExceedsNeed - true if the initial capacity exceeds the potential\n * @return {Array} destructurable array of form:\n * [ initBookingList, initWaitingList, existingBookList, existingWaitList ]\n * - all lists filter out the ids of attendees who are restricted from booking or waiting on the session\n */\nexport const useBookingLists = (\n  session,\n  attendees,\n  initialCapacityExceedsNeed\n) => {\n  const attendeeIsDisabled = useIsAttendeeDisabledCallback(session, attendees)\n\n  const waitingListIsAvailable = session?.capacity?.isWaitingListAvailable\n\n  return useMemo(() => {\n    // existing waiting list, as determined strictly by the data, except we filter out any unbookable attendees\n    const existingWaitingList = getExistingWaitIds(\n      session?.identifier,\n      attendees\n    ).filter(id => !attendeeIsDisabled(id))\n\n    // the initial waiting list to be used on the group booking modal. If the waiting list is available,\n    // we use the existing waiting list, otherwise this list is empty\n    const initWaitingList = waitingListIsAvailable ? existingWaitingList : []\n\n    // the booking list, as determined by the data alone, without any pre-selection done,\n    // but still filtering out unbookable attendees\n    const existingBookingList = getExistingBookIds(\n      session?.identifier,\n      attendees\n    ).filter(id => !attendeeIsDisabled(id))\n\n    const shouldPreselect = shouldPreselectAttendees(\n      initialCapacityExceedsNeed,\n      initWaitingList,\n      existingBookingList\n    )\n\n    // The initial booking list to be used on the group booking modal. This might be equal to the\n    // existing booking list, or it may be a list of pre-selected attendees given certain conditions\n    const initBookingList = getInitialBookingIds(\n      existingBookingList,\n      attendees,\n      attendeeIsDisabled,\n      shouldPreselect\n    )\n\n    return [\n      initBookingList,\n      initWaitingList,\n      existingBookingList,\n      initWaitingList,\n    ]\n  }, [\n    session,\n    attendees,\n    attendeeIsDisabled,\n    initialCapacityExceedsNeed,\n    waitingListIsAvailable,\n  ])\n}\n","import { useMemo } from 'react'\nimport { countAttendeesByTicket } from 'SVUtils/models/attendees/countAttendeesByTicket'\nimport { useIsAttendeeDisabledCallback } from 'SVHooks/models/attendees/useIsAttendeeDisabledCallback'\nimport { parseSessionCapacity } from 'SVUtils/booking/parseSessionCapacity'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\n\n/**\n * Helper for useGroupCounts that counts the number of\n * attendees who are disabled (according to isDisabledFn)\n * @param {Array<import('SVModels/Attendee').Attendee>} attendees - list of attendees\n * @param {Function<string, boolean>} isDisabledFn - returns true if the attendee is disabled from booking a session\n */\nconst countDisabled = (attendees, isDisabledFn) => {\n  const disabledAttendees = attendees.filter(att =>\n    isDisabledFn(att.bookedTicketIdentifier)\n  )\n  return disabledAttendees.length\n}\n\n/**\n * Computes some memoized counts of the attendee data structures\n * @param {import('SVModels/Session').Session} - the session for which to compute the counts\n * @return {Object} object with the computed values\n * {\n *  - sortedAttendeeCount: count of all attendees who are sorted into tickets\n *  - bookableAttendeeCount: number of attendees who are permitted to book the passed-in session\n *  - initialCapacityExceedsNeed: true if the session is unlimited or the remainingCount of the session is greater\n *                                than the bookable attendee count\n * }\n */\nexport const useGroupCounts = session => {\n  const { remainingCount } = parseSessionCapacity(session?.capacity)\n  const isUnlimited = session?.capacity?.isUnlimited\n\n  const { attendees, attendeesByTicket } = useStoreItems([\n    'attendees',\n    'attendeesByTicket',\n  ])\n\n  const isDisabled = useIsAttendeeDisabledCallback(session, attendees)\n\n  return useMemo(() => {\n    const sortedAttendeeCount = countAttendeesByTicket(attendeesByTicket)\n    const disabledCount = countDisabled(attendees, isDisabled)\n\n    // number of attendees that are eligible to book this session\n    const bookableAttendeeCount = sortedAttendeeCount - disabledCount\n\n    // only show the capacity of the session if the number of attendees exceeds the capacity\n    const initialCapacityExceedsNeed =\n      isUnlimited || remainingCount > bookableAttendeeCount\n\n    return {\n      sortedAttendeeCount,\n      bookableAttendeeCount,\n      initialCapacityExceedsNeed,\n    }\n  }, [ isUnlimited, attendees, attendeesByTicket, isDisabled, remainingCount ])\n}\n","import React, { useEffect } from 'react'\nimport { useStyle } from '@keg-hub/re-theme'\nimport { BaseModal } from './baseModal'\nimport {\n  GroupBookerBody,\n  GroupBookerFooter,\n} from 'SVComponents/booking/groupBooker'\nimport { GroupBookingProvider } from 'SVContexts/booking/groupBookingProvider'\nimport { useGroupBookingContext } from 'SVContexts/booking/groupBookingContext'\nimport { hideActiveModal } from 'SVActions/modals/hideActiveModal'\n\n/**\n * Wrapper around BaseModal that hooks into the booking context\n * to ensure its state is up to date whenever the group booking\n * modal is opened.\n *\n * @param {Object} props - BaseModal props\n */\nconst RefreshedModal = props => {\n  const { actions } = useGroupBookingContext()\n  useEffect(() => {\n    props.visible && actions?.reset()\n  }, [props.visible])\n\n  return <BaseModal {...props} />\n}\n\n/**\n * GroupBooking Modal\n * @param {object} props\n * @param {import('SVModels/session').Session} props.session\n * @param {boolean} props.visible\n */\nexport const GroupBooking = ({ visible, session }) => {\n  if (!session) return null\n\n  const groupBookingStyles = useStyle('modal.groupBooking')\n\n  return (\n    <GroupBookingProvider session={session}>\n      <RefreshedModal\n        className={`ef-modal-group`}\n        title={session.name}\n        visible={visible}\n        Body={\n          <GroupBookerBody\n            session={session}\n            styles={groupBookingStyles?.content?.body}\n          />\n        }\n        Footer={\n          <GroupBookerFooter\n            onCancelPress={hideActiveModal}\n            styles={groupBookingStyles?.content?.footer}\n          />\n        }\n      />\n    </GroupBookingProvider>\n  )\n}\n","import { KeyStore } from 'SVNative/keyStore'\nimport { validate, get, set } from '@keg-hub/jsutils'\nimport { isValidStoragePath, isValidKeyStore } from './validators'\nimport { upsert } from 'SVActions/items'\nimport { Values } from 'SVConstants'\n\nconst { LOADED_FROM_STORAGE } = Values.Plugins?.LocalStorage\n\n/**\n * Attempts to parse the value pulled from localStorage.\n * @param {string} path\n * @param {string} localStorageValue\n * @returns {*} the parsed value, or null if unparseable\n */\nconst parseValue = (path, localStorageValue) => {\n  let parsedValue\n  try {\n    parsedValue = JSON.parse(localStorageValue)\n  }\n  catch (err) {\n    console.warn('Could not parse local storage for path', path, '\\n\\t', err)\n    parsedValue = undefined\n  }\n\n  !parsedValue &&\n    console.warn(\n      `Path \"${path}\" contained no value in localStorage, so nothing is loaded`\n    )\n\n  return parsedValue\n}\n\n/**\n * Builds an item object for loadFromLocalStorage.\n * Uses the keys with the value, if keys exist, otherwise just returns value\n * @param {Array<string>} keys\n * @param {*} value\n * @example\n * buildItem(['a', 'b'], 55) -> { a: { b: 55 }}\n * buildItem([], 55) -> 55\n */\nconst buildItem = (keys, value) => {\n  const itemPathValue = get(value, keys, value)\n  return keys.length ? set({}, keys, itemPathValue) : value\n}\n\n/**\n * Loads a path from localStorage, then calls onLoad with item category, key, and data\n * onLoad defaults to upserting the loaded data into the items store\n * @param {Object} params\n * @param {string} params.path - path to value in localStorage and items store tree. Example: 'users.adam', where 'users' is the items category and 'adam' is the key\n * @param {Object?} params.storage - an instance of the Storage class defined in keg-core, with getItem/setItem functions for localStorage\n * @param {Function?} params.onLoad - callback for loaded data from local storage, of form: ({ category, key, item, items, meta }) => { ... }. Defaults to updating the store.\n * @return {void}\n */\nexport const loadFromLocalStorage = async (params = {}) => {\n  const { path, storage = KeyStore, onLoad = upsert } = params\n\n  const [valid] = validate(\n    { path, storage },\n    {\n      path: isValidStoragePath,\n      storage: isValidKeyStore,\n    }\n  )\n  if (!valid) return Promise.reject('Invalid input')\n\n  // destructure out the category, key, and property path from the path string\n  const [ category, key, ...propertyKeys ] = path.split('.')\n\n  // get the data from local storage\n  const localStorageValue = await storage.getItem(path)\n\n  // parse it, since it was stored as a string\n  const parsedValue = parseValue(path, localStorageValue)\n\n  // if no value is stored, there is nothing to load, so return\n  if (!parsedValue) return Promise.resolve()\n\n  const item = key && buildItem(propertyKeys, parsedValue)\n  const items = !key && parsedValue\n\n  // call the callback, which by default will upsert the item or items into the items store\n  onLoad({\n    category,\n    key,\n    item,\n    items,\n    meta: { [LOADED_FROM_STORAGE]: true },\n  })\n}\n","import React, { useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { Button } from '@keg-hub/keg-components'\nimport { useTheme, useStylesCallback } from '@keg-hub/re-theme'\nimport { checkCall } from '@keg-hub/jsutils'\nimport { Values } from 'SVConstants/values'\n\nconst { SESSION_BOOKING_LABEL_MAP } = Values\n\n/**\n * Builds the dynamic styles for LabelButton\n * @param {Object} theme - theme obj\n * @param {Object} extra - extra styles to add\n */\nconst buildStyles = (theme, extra) => {\n  return theme.get(\n    theme.get('labelButton'),\n    {\n      selected: {\n        active: { main: { opacity: 0.4 } },\n      },\n      unselected: {},\n    },\n    extra.styles\n  )\n}\n\n/**\n * Simple label component that can be clicked.\n * @param {Object} props\n * @param {Object} props.styles - custom button styles that will override those defined in the theme file's main object. Object should define default, hover, and active themes for the different states of the button. @see `buildStyles`\n * @param {import('SVModels/label').Label} props.label - the label model instance\n * @param {Function} props.onPress - when clicked, calls onPress and passes the label object to it\n */\nexport const LabelButton = ({\n  styles,\n  label = {},\n  onPress,\n  toggledOn = true,\n}) => {\n  const theme = useTheme()\n  const extraStyles = useMemo(\n    () => ({\n      styles,\n      className: label.className,\n    }),\n    [ styles, label.className ]\n  )\n\n  // build the main style for the button, memoized\n  const mainStyle = useStylesCallback(\n    buildStyles,\n    [ label.className, theme.get('labelButton') ],\n    extraStyles\n  )\n\n  const clickHandler = () => checkCall(onPress, label)\n\n  return (\n    <Button\n      className={label.className}\n      styles={toggledOn ? mainStyle.selected : mainStyle.unselected}\n      content={SESSION_BOOKING_LABEL_MAP[label.identifier] || label.name}\n      onClick={clickHandler}\n    />\n  )\n}\n\nLabelButton.propTypes = {\n  style: PropTypes.object,\n  label: PropTypes.object,\n  onPress: PropTypes.func,\n}\n","import { dispatch, getStore } from 'SVStore'\nimport { ActionTypes, Values } from 'SVConstants'\nconst { CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * adds/remove the item to/from selectedFilters\n * @param {import('SVModels/label').Label} label\n */\nexport const updateSelectedFilters = label => {\n  const { items } = getStore()?.getState()\n  const selectedFilters = items?.filters?.selectedFilters || []\n\n  // add the item if it doesn't exist\n  // remove the item if it does exist\n  const shouldRemove = selectedFilters.some(\n    item => item.identifier === label.identifier\n  )\n\n  const updatedFilters = shouldRemove\n    ? selectedFilters.filter(item => item.identifier !== label.identifier)\n    : selectedFilters.concat(label)\n\n  dispatch({\n    type: ActionTypes.SET_ITEM,\n    payload: {\n      category: CATEGORIES.FILTERS,\n      key: SUB_CATEGORIES.SELECTED_FILTERS,\n      item: updatedFilters,\n    },\n  })\n}\n","import { get, noPropArr } from '@keg-hub/jsutils'\nimport { getStore, dispatch } from 'SVStore'\nimport { ActionTypes, Values } from 'SVConstants'\n\nconst { CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * Checks if any sessions have a waiting list available\n * Then updates the store base on the result\n * @param {Array.<import('SVModels/session').Session>} sessions\n *\n */\nexport const setWaitingListActive = sessions => {\n  const { items } = getStore()?.getState()\n  sessions = sessions || items?.sessions || noPropArr\n\n  const searchPath = [ 'capacity', 'isWaitingListAvailable' ]\n  const waitingListActive = sessions.some(session => get(session, searchPath))\n\n  dispatch({\n    type: ActionTypes.UPSERT_ITEM,\n    payload: {\n      item: waitingListActive,\n      category: CATEGORIES.SETTINGS,\n      key: SUB_CATEGORIES.WAITING_LIST_ACTIVE,\n    },\n  })\n}\n","import { dispatch, getStore } from 'SVStore'\nimport { ActionTypes, Values } from 'SVConstants'\nimport { buildHourSessionsMap } from 'SVUtils/models/sessions/buildHourSessionsMap'\nimport { validate, isArr } from '@keg-hub/jsutils'\n\nconst { CATEGORIES } = Values\n/**\n *  map AgendaSessions using sessions and agenda day numbers\n * @param {Array<import('SVModels/session').Session>} sessions\n * @param {Array} agendaDays\n */\nexport const setAgendaSessions = (sessions, agendaDays) => {\n  const [valid] = validate({ sessions, agendaDays }, { $default: isArr })\n  if (!valid) return\n\n  const { items } = getStore()?.getState()\n  const military = items.settings?.displayProperties?.timeFormat === '24'\n  // object will look something like:\n  // { ordered by timeblock\n  //   1: [{timeBlock: '9:00', sessions: [session1, session2]}] //day 1\n  //   2: [{timeBlock: '13:00', sessions: [session1]}, {timeBlock: '15:00', sessions: [session1]}], //day 2\n  // }\n  const agendaSessions = agendaDays.reduce((map, nextDay) => {\n    map[nextDay.dayNumber] = buildHourSessionsMap(\n      sessions,\n      nextDay.dayNumber,\n      military\n    )\n    return map\n  }, {})\n\n  dispatch({\n    type: ActionTypes.SET_ITEMS,\n    payload: {\n      category: CATEGORIES.AGENDA_SESSIONS,\n      items: agendaSessions,\n    },\n  })\n}\n","import { getStore, dispatch } from 'SVStore'\nimport { ActionTypes, Values } from 'SVConstants'\nimport { setWaitingListActive } from '../booking/setWaitingListActive'\nimport { setAgendaSessions } from 'SVActions/session/setAgendaSessions'\nimport {\n  sessionsFromLabelFilters,\n  sessionsFromStateFilters,\n} from 'SVUtils/filters'\n\nconst { CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * Updates the state of the active filters with the sate from the selected filters\n * @param {Array<Session>} sessions - List of sessions the will be filtered by the active filters\n * @param {Array.<import('SVModels/agendaDay').AgendaDay>} agendaDays - Days of the sessions\n *\n * @returns {void}\n */\nexport const applySessionFilters = (sessions, agendaDays) => {\n  const { items } = getStore()?.getState()\n  const selectedFilters = items?.filters?.selectedFilters || []\n\n  sessions = sessions || items?.sessions\n  agendaDays = agendaDays || items?.agendaDays\n\n  const filteredSessions =\n    selectedFilters.length > 0\n      ? sessionsFromLabelFilters(\n          selectedFilters,\n          sessionsFromStateFilters(selectedFilters, sessions)\n        )\n      : sessions\n\n  // Set the waiting list filter label for only viewable sessions\n  setWaitingListActive(filteredSessions)\n\n  // update agenda sessions store\n  setAgendaSessions(filteredSessions, agendaDays)\n\n  // set the current selectedFilters to activeFilters\n  dispatch({\n    type: ActionTypes.SET_ITEM,\n    payload: {\n      category: CATEGORIES.FILTERS,\n      key: SUB_CATEGORIES.ACTIVE_FILTERS,\n      item: selectedFilters,\n    },\n  })\n}\n","import { dispatch, getStore } from 'SVStore'\nimport { ActionTypes, Values } from 'SVConstants'\nconst { CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * For cases where you select some filter items but decide not to apply them\n * This ensures that selectedFilters at least have the same values as activeFilters\n */\nexport const cancelSelectedFilters = () => {\n  const { items } = getStore()?.getState()\n  const activeFilters = items?.filters?.activeFilters || []\n\n  dispatch({\n    type: ActionTypes.SET_ITEM,\n    payload: {\n      category: CATEGORIES.FILTERS,\n      key: SUB_CATEGORIES.SELECTED_FILTERS,\n      item: activeFilters,\n    },\n  })\n}\n","import { useMemo } from 'react'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\nimport { Values } from 'SVConstants/values'\nimport {\n  sessionsFromLabelFilters,\n  sessionsFromStateFilters,\n} from 'SVUtils/filters'\n\nconst { CATEGORIES } = Values\n/**\n * Returns an array of sessions based on the selected filters\n *\n * @returns {Array<import('SVModels/session').Session>}\n */\nexport const useFilteredSessions = () => {\n  const { filters, sessions } = useStoreItems([\n    CATEGORIES.FILTERS,\n    CATEGORIES.SESSIONS,\n  ])\n  return useMemo(() => {\n    const hasSelectedFilters = Boolean(filters?.selectedFilters.length)\n\n    // do basic filtering on SELECTED labels so we can get the count\n    return hasSelectedFilters\n      ? sessionsFromLabelFilters(\n          filters?.selectedFilters,\n          sessionsFromStateFilters(filters?.selectedFilters, sessions)\n        )\n      : []\n  }, [ filters, sessions ])\n}\n","import React, { useMemo, useCallback } from 'react'\nimport { useTheme } from '@keg-hub/re-theme'\nimport { BaseModal } from './baseModal'\nimport { View, Text, ScrollView } from '@keg-hub/keg-components'\nimport { EvfButton } from 'SVComponents/button/evfButton'\nimport { sortLabels } from 'SVUtils'\nimport { LabelButton } from 'SVComponents/labels/labelButton'\nimport { Label } from 'SVModels/label'\nimport { Values } from 'SVConstants/values'\nimport { reduceObj, wordCaps, filterObj, noPropArr } from '@keg-hub/jsutils'\nimport {\n  updateSelectedFilters,\n  applySessionFilters,\n  cancelSelectedFilters,\n  clearSelectedFilters,\n} from 'SVActions/session/filters'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\nimport { useFilteredSessions, useWaitingListActive } from 'SVHooks/sessions'\nimport { hideActiveModal } from 'SVActions/modals/hideActiveModal'\n\nconst { SESSION_BOOKING_STATES, CATEGORIES, BUTTON_TYPES } = Values\n\n/**\n *\n * @param {object} props\n */\nexport const Filter = ({ visible, labels }) => {\n  const theme = useTheme()\n  const filterStyles = theme.get('modal.filter')\n\n  // sort the labels alphabetically\n  const labelsMemo = useMemo(() => sortLabels(labels), [labels])\n  const applyCb = useCallback(() => {\n    applySessionFilters()\n    hideActiveModal()\n  }, [ applySessionFilters, hideActiveModal ])\n\n  const { filters } = useStoreItems([CATEGORIES.FILTERS])\n  const hasSelectedFilters = Boolean(filters?.selectedFilters.length)\n  const filteredSessions = useFilteredSessions()\n\n  return (\n    <BaseModal\n      onDismiss={cancelSelectedFilters}\n      title={'Filter'}\n      visible={visible}\n      Body={\n        <Body\n          styles={filterStyles?.content?.body}\n          labels={labelsMemo}\n          selectedFilters={filters?.selectedFilters}\n          hideCounter={!hasSelectedFilters}\n          filteredSessions={filteredSessions}\n        />\n      }\n      Footer={\n        <Footer\n          disableApply={hasSelectedFilters && filteredSessions?.length === 0}\n          styles={filterStyles?.content?.footer}\n          onButtonPress={applyCb}\n          hasSelectedFilters={hasSelectedFilters}\n        />\n      }\n    />\n  )\n}\n\n/**\n *\n * @param {object} props\n * @param {object} props.styles - default from modal.filter.body.topSection\n * @param {Array.<import('SVModels/session').Session>} props.filteredSessions\n * @param {Boolean} props.hideCounter\n */\nconst TopSection = ({ styles, filteredSessions, hideCounter = false }) => {\n  return (\n    <View style={styles?.main}>\n      <Text\n        style={styles?.leftText}\n        className={'ef-modal-body-header'}\n      >\n        Only Show:\n      </Text>\n      <ResultsCounter\n        hide={hideCounter}\n        count={filteredSessions.length}\n        styles={styles}\n      />\n    </View>\n  )\n}\n\n/**\n * ResultsCounter\n * displays the count of filter\n * @param {object} props\n * @param {object} props.styles\n * @param {object} props.hide - whether to show/hide this component\n * @param {Number=} props.count\n */\nconst ResultsCounter = ({ styles, hide, count = 0 }) => {\n  const resultText = `${count} ${\n    count > 1 || count === 0 ? 'results' : 'result'\n  }`\n  return hide ? null : (\n    <Text\n      style={styles?.resultsText}\n      className={'ef-modal-body-highlight'}\n    >\n      { resultText }\n    </Text>\n  )\n}\n\n/**\n * Checks whether or not a particular label should be on the 'toggled on' state or not\n * @param {number} selectedCount\n * @param {Array.<import('SVModels/label').Label>} selectedFilters\n * @param {import('SVModels/label').Label} label\n *\n * @returns {boolean}\n */\nconst useLabelOn = (selectedCount, selectedFilters, label) => {\n  // Check selectedCount before doing the loop. If none are selected, we save a few cpu cycles\n  return useMemo(() => {\n    return (\n      selectedCount &&\n      selectedFilters.some(item => item.identifier === label.identifier)\n    )\n  }, [ selectedFilters, selectedCount, label ])\n}\n\n/**\n * FilterLabelButton - Renders the label button component for a label object\n * Calls hook useLabelOn to check if the label is active of not\n * @param {Object} props\n * @param {Object} props.styles - styles to be applied to LabelButton\n * @param {import('SVModels/label').Label} props.label - the label model instance\n * @param {Array.<import('SVModels/label').Label>} props.selectedFilters - current selected filters\n * @param {number} selectedFilters - Total number of selected filters\n */\nconst FilterLabelButton = props => {\n  const { label, styles, selectedCount, selectedFilters } = props\n\n  const isLabelOn = useLabelOn(selectedCount, selectedFilters, label)\n\n  return (\n    <LabelButton\n      label={label}\n      styles={styles}\n      toggledOn={!selectedCount || isLabelOn}\n      onPress={updateSelectedFilters}\n    />\n  )\n}\n\n/**\n * LabelButtons\n * Builds the filter items\n * Expected behavior:\n *   - All filters are 'toggled on' by default when no filter is selected\n *   - Once a filter item is selected, all are toggled off except for the selected item(s)\n * @param {object} props\n * @param {object} props.styles - styles to be applied to LabelButton\n * @param {Array.<import('SVModels/label').Label>} props.labels - array of label items\n * @param {Array.<import('SVModels/label').Label>} props.selectedFilters - current selected filters\n */\nconst LabelButtons = React.memo(\n  ({ styles, labels, selectedFilters = noPropArr }) => {\n    const selectedCount = selectedFilters.length\n    return labels.map(label => {\n      return (\n        <FilterLabelButton\n          key={label.name}\n          label={label}\n          styles={styles}\n          selectedFilters={selectedFilters}\n          selectedCount={selectedCount}\n        />\n      )\n    })\n  }\n)\n\n/**\n * Creates an array of Labels based on the passed in object\n * @param {object} bookingStates - obj of the form\n *                               - {\n *                                   keyName: string,\n *                                   ...etc\n *                                 }\n * @returns {Array.<import('SVModels/label').Label>}\n */\nconst useStateLabels = bookingStates => {\n  const waitingListActive = useWaitingListActive()\n\n  return useMemo(() => {\n    const { WAITING_LIST, ON_WAITING_LIST } = SESSION_BOOKING_STATES\n    return reduceObj(\n      bookingStates,\n      (key, value, labels) => {\n        ;(waitingListActive ||\n          (value !== WAITING_LIST && value !== ON_WAITING_LIST)) &&\n          labels.push(new Label({ name: wordCaps(value), identifier: key }))\n\n        return labels\n      },\n      []\n    )\n  }, [ bookingStates, waitingListActive ])\n}\n\nconst filteredBookingStates = filterObj(\n  SESSION_BOOKING_STATES,\n  (_, val) =>\n    val != SESSION_BOOKING_STATES.FULLY_BOOKED &&\n    val != SESSION_BOOKING_STATES.READ_ONLY\n)\n/**\n * MiddleSection\n * @param {object} props\n * @param {object} props.styles - default from modal.filter.body.middleSection\n * @param {Array.<import('SVModels/label').Label>} props.labels - array of label items\n * @param {Array.<import('SVModels/label').Label>} props.selectedFilters - current selected filters\n */\nconst MiddleSection = ({ styles, labels, selectedFilters }) => {\n  const stateLabels = useStateLabels(filteredBookingStates)\n\n  return (\n    <ScrollView\n      style={styles?.main}\n      contentContainerStyle={styles?.container}\n    >\n      <View style={styles?.labelButtons?.main}>\n        <LabelButtons\n          styles={styles.labelButtons?.item}\n          labels={labels}\n          selectedFilters={selectedFilters}\n        />\n      </View>\n\n      <View style={styles?.stateButtons?.main}>\n        <LabelButtons\n          styles={styles?.stateButtons?.item}\n          labels={stateLabels}\n          selectedFilters={selectedFilters}\n        />\n      </View>\n    </ScrollView>\n  )\n}\n\n/**\n * Body\n * @param {object} props\n * @param {object} props.styles\n * @param {Array.<import('SVModels/label').Label>} props.labels - labels to display\n * @param {Array.<import('SVModels/session').Session>} props.filteredSessions\n * @param {Array.<import('SVModels/label').Label>} props.selectedFilters\n * @param {Boolean} props.hideCounter - to hide the results counter or not\n */\nconst Body = ({\n  styles,\n  labels,\n  filteredSessions,\n  selectedFilters,\n  hideCounter,\n}) => {\n  return (\n    <View style={styles?.main}>\n      <TopSection\n        styles={styles?.topSection}\n        filteredSessions={filteredSessions}\n        hideCounter={hideCounter}\n      />\n      <MiddleSection\n        labels={labels}\n        styles={styles?.middleSection}\n        selectedFilters={selectedFilters}\n      />\n    </View>\n  )\n}\n\n/**\n * Footer\n * @param {object} props\n * @param {object} props.styles - default from modal.filter.body.bottomSection theme\n * @param {Function} props.onButtonPress\n * @param {boolean} props.hasSelectedFilters - whether or not the selectedFilters state is empty\n * @param {boolean} props.disableApply - whether the apply btn is disabled or not\n */\nconst Footer = ({\n  styles,\n  onButtonPress,\n  hasSelectedFilters,\n  disableApply,\n}) => {\n  return (\n    <View style={styles?.main}>\n      { hasSelectedFilters && (\n        <EvfButton\n          buttonType={BUTTON_TYPES.LINK}\n          styles={styles?.clearButton}\n          onClick={clearSelectedFilters}\n          text={'Clear all'}\n        />\n      ) }\n      <EvfButton\n        buttonType={BUTTON_TYPES.MODAL_PRIMARY}\n        disabled={disableApply}\n        type={'primary'}\n        styles={styles?.applyButton}\n        onClick={onButtonPress}\n        text={'APPLY'}\n      />\n    </View>\n  )\n}\n","import React from 'react'\nimport { useTheme } from '@keg-hub/re-theme'\nimport { BaseModal } from './baseModal'\nimport { View, Text, ScrollView } from '@keg-hub/keg-components'\nimport { EvfButton } from 'SVComponents/button/evfButton'\nimport { hideActiveModal } from 'SVActions/modals/hideActiveModal'\nimport { Values } from 'SVConstants'\nconst { BUTTON_TYPES } = Values\n\n/**\n * Alert modal\n * @param {object} props\n * @param {boolean} props.visible\n * @param {string} props.title - text to show in header\n * @param {string} props.message - text to show in body\n * @param {'error'|null} props.type - alert type\n */\nexport const Alert = ({ visible, title, message }) => {\n  const theme = useTheme()\n  const alertStyles = theme.get('modal.alert')\n\n  return (\n    <BaseModal\n      className={`ef-modal-alert`}\n      title={title}\n      visible={visible}\n      Body={<Body\n        styles={alertStyles?.content?.body}\n        message={message}\n      />}\n      Footer={\n        <Footer\n          styles={alertStyles?.content?.footer}\n          onButtonPress={hideActiveModal}\n        />\n      }\n    />\n  )\n}\n\n/**\n * Body of alert modal\n * @param {object} props\n * @param {object} props.styles\n * @param {string} props.message - string to display\n */\nconst Body = ({ styles, message }) => {\n  return (\n    <View\n      style={styles?.main}\n      className={[ 'ef-modal-sub-header', 'ef-modal-alert-body' ]}\n    >\n      <ScrollView\n        style={styles?.textContainer?.main}\n        contentContainerStyle={styles?.textContainer?.contentContainerStyle}\n      >\n        <Text\n          className={`ef-modal-alert-text`}\n          style={styles?.text}\n        >\n          { message }\n        </Text>\n      </ScrollView>\n    </View>\n  )\n}\n\n/**\n * Footer\n * @param {object} props\n * @param {object} props.styles\n * @param {Function} props.onButtonPress\n */\nconst Footer = ({ styles, onButtonPress }) => {\n  return (\n    <EvfButton\n      buttonType={BUTTON_TYPES.MODAL_PRIMARY}\n      className={`ef-modal-alert-button`}\n      type={'primary'}\n      styles={styles?.button}\n      onClick={onButtonPress}\n      text={'OK'}\n    />\n  )\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { View } from '@keg-hub/keg-components'\nimport { LabelButton } from './labelButton'\nimport { useTheme } from '@keg-hub/re-theme'\n\n/**\n * A list of labels\n * @param {Object} props\n * @param {Object} props.style - style for the root list\n * @param {Object} props.itemStyle - style for individual labels\n * @param {Function} props.onItemPress - callback fired when a label is pressed. Has form: (label) => { ... }\n * @param {Component} props.LabelComponent - optional custom component that will be used for rendering the individual labels.\n * @param {Array<import('SVModels/label').Label>} props.labels - the label model instance\n */\nexport const LabelList = props => {\n  const {\n    style = {},\n    itemStyle = {},\n    labels = [],\n    LabelComponent = LabelButton,\n    onItemPress,\n  } = props\n\n  const theme = useTheme()\n  const labelStyle = theme.get('labelList.item', itemStyle)\n\n  return (\n    <View\n      className={`ef-label-list`}\n      style={[ theme.get('labelList.main'), style ]}\n    >\n      { labels.map(label => (\n        <LabelComponent\n          key={label.name}\n          styles={labelStyle}\n          label={label}\n          onPress={onItemPress}\n        />\n      )) }\n    </View>\n  )\n}\n\nLabelList.propTypes = {\n  style: PropTypes.object,\n  itemStyle: PropTypes.object,\n  labels: PropTypes.arrayOf(PropTypes.object),\n  LabelComponent: PropTypes.elementType,\n  onItemPress: PropTypes.func,\n}\n","import { Values } from 'SVConstants'\nimport { getStore } from 'SVStore'\nimport { setActiveModal } from 'SVActions/modals/setActiveModal'\nimport { Modal } from 'SVModels/modal'\nimport { sessionBookingRequest } from 'SVActions/session/booking/sessionBookingRequest'\nimport { devLog } from 'SVUtils/logs'\nimport { checkCall, isArr } from '@keg-hub/jsutils'\n\nconst { EVENTS, MODAL_TYPES } = Values\n\n/**\n * Helper for selectSession.\n * Requests the booking, depending on the action type\n * @param {string} actionType - either EVENTS.SESSION_BOOKING_REQUEST, or EVENTS.SESSION_WAITING_LIST_REQUEST\n * @param {string} sessionId\n * @param {Array<string>} attendeeIds\n */\nconst requestBooking = (actionType, sessionId, attendeeIds) => {\n  sessionBookingRequest?.(\n    sessionId,\n    actionType === EVENTS.SESSION_BOOKING_REQUEST && attendeeIds,\n    actionType === EVENTS.SESSION_WAITING_LIST_REQUEST && attendeeIds\n  )\n}\n\n/**\n * Either books the current session or opens up group booking modal\n * based on the # of attendees available\n * @param {import('SVModels/session').Session} session\n * @param {Array} attendees - Group of attendee ids to book for a session\n * @param {string} actionType - Type of booking action to call\n */\nexport const selectSession = (\n  session,\n  attendees,\n  actionType = EVENTS.SESSION_BOOKING_REQUEST\n) => {\n  if (!session)\n    return devLog.warn(\n      'Action \"selectSession\" requires a valid session. Received: ',\n      session\n    )\n\n  // Check if there is an attendees override, and use that instead of the stored attendees\n  const attendeesCp = isArr(attendees)\n    ? attendees\n    : checkCall(() => {\n      const { items } = getStore()?.getState()\n      return items && Array.from(items.attendees)\n    })\n\n  // If more then 1 attendee, open group booking modal\n  // Otherwise get an array of the attendee ids\n  attendeesCp.length > 1\n    ? setActiveModal(\n        new Modal({\n          type: MODAL_TYPES.GROUP_BOOKING,\n          data: {\n            session,\n            attendees: attendeesCp,\n          },\n        })\n      )\n    : requestBooking(\n      actionType,\n      session.identifier,\n      attendeesCp.map(attendee => attendee?.bookedTicketIdentifier)\n    )\n}\n","import { useMemo } from 'react'\nimport { checkCall } from '@keg-hub/jsutils'\nimport { useGroupCounts } from './useGroupCounts'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\nimport { useBookingTimeConflicts } from './useBookingTimeConflicts'\nimport { getBookingState } from 'SVUtils/models/sessions/getBookingState'\nimport { bookingStateFactory } from 'SVUtils/models/sessions/bookingStateFactory'\nimport { getExistingBookIds } from 'SVUtils/booking/getExistingBookIds'\nimport { getExistingWaitIds } from 'SVUtils/booking/getExistingWaitIds'\nimport { Values } from 'SVConstants'\nconst { BOOKING_MODES, CATEGORIES } = Values\n\n/**\n * Custom hook to get a lists for attendees that have booked the session, or are on the waiting list\n * @param {string} sessionId - Id of the current session\n * @param {Array} attendees - Group of attendees from the store\n *\n * @returns {Object} Lists of attendees that have booked the session or are on the waiting list\n */\nconst useBookingLists = (sessionId, attendees) => {\n  return useMemo(\n    () => ({\n      bookingList: getExistingBookIds(sessionId, attendees),\n      waitingList: getExistingWaitIds(sessionId, attendees),\n    }),\n    [ sessionId, attendees ]\n  )\n}\n\n/**\n * Custom hook to get a set of items from the store\n * <br/>Also gets the current booking mode based on the amount of attendees in the store\n *\n * @returns {Object} Data extracted from the store\n */\nconst useStoreData = () => {\n  const storeData = useStoreItems([\n    CATEGORIES.SETTINGS,\n    CATEGORIES.ATTENDEES,\n    CATEGORIES.AGENDA_SESSIONS,\n    CATEGORIES.PENDING_SESSION,\n  ])\n\n  return {\n    ...storeData,\n    bookingMode:\n      storeData?.attendees?.length > 1\n        ? BOOKING_MODES.GROUP\n        : BOOKING_MODES.SINGLE,\n  }\n}\n\n/**\n * Custom hook to build a booking model from the passed in arguments\n *\n * @param {string} state - The current booking state of the session\n * @param {import('SVModels/session').Session} session\n * @param {string} bookingMode - Current mode of booking for the session (single|group)\n * @param {Array} bookingLists - List of attendee ids that are booked or are on the waiting list\n * @param {Object} timeConflicts - Key value pairs of attendees booked in conflicting sessions\n * @param {Array} bookableCount - Attendees that can book the current session\n * @param {import('SVModels/PendingSession').PendingSession} pendingSession - the object indicating if a session has submitted a booking request\n *\n * @returns {import('SVModels/session/bookingState').BookingState} model\n */\nconst useBookingFactory = (\n  state,\n  session,\n  bookingMode,\n  bookingLists,\n  timeConflicts,\n  bookableCount,\n  pendingSession\n) => {\n  return useMemo(\n    () =>\n      checkCall(bookingStateFactory[state], {\n        session,\n        bookingMode,\n        timeConflicts,\n        bookableCount,\n        pendingSession,\n        ...bookingLists,\n      }) || null,\n    [\n      state,\n      session,\n      bookingMode,\n      bookingLists,\n      timeConflicts,\n      bookableCount,\n      pendingSession,\n    ]\n  )\n}\n\n/**\n * Custom hook to get the children and styles of the booking button\n * <br/>Base on the session and it's current state\n * @param {import('SVModels/session').Session} props.session\n */\nexport const useBookingState = session => {\n  const sessionId = session?.identifier\n  const state = getBookingState(session)\n\n  // Items from the store to determin the current booking state\n  const {\n    attendees,\n    agendaSessions,\n    bookingMode,\n    settings,\n    pendingSession,\n  } = useStoreData()\n\n  // Lists for attendees that have booked the session, or are on the waiting list\n  const bookingLists = useBookingLists(sessionId, attendees)\n\n  // Attendees with time conflicts with the current session\n  const timeConflicts = useBookingTimeConflicts(\n    session,\n    attendees,\n    agendaSessions[settings?.agendaSettings?.activeDayNumber ?? 1]\n  )\n\n  // Attendees that can book the current session\n  const { bookableAttendeeCount } = useGroupCounts(session)\n\n  // Create the booking model from the booking factory\n  return useBookingFactory(\n    state,\n    session,\n    bookingMode,\n    bookingLists,\n    timeConflicts,\n    bookableAttendeeCount,\n    pendingSession\n  )\n}\n","import React, { useCallback } from 'react'\nimport { Text, View } from '@keg-hub/keg-components'\nimport { EvfButton } from 'SVComponents/button/evfButton'\nimport { selectSession } from 'SVActions/session/selectSession'\nimport { useBookingState } from 'SVHooks/booking/useBookingState'\nimport { useStylesCallback, useStyle } from '@keg-hub/re-theme'\nimport { noPropObj, get } from '@keg-hub/jsutils'\nimport { Values } from 'SVConstants'\nconst { BOOKING_MODES, EVENTS, SESSION_BOOKING_STATES, BUTTON_TYPES } = Values\n\n/**\n * Helper to build the styles for the booking button\n * @param {Object} theme - Global theme object\n * @param {boolean} disabled - Should the disabled styles be included\n * @param {string} style - Custom styles passed from a parent component\n *\n * @returns {Object} - Joined styles object from different locations\n */\nconst buildStyles = (theme, _, disabled, iconName, style) => {\n  const styles = theme.get(`button.evfButton`)\n\n  const bookingStyles = styles?.booking || noPropObj\n  const disabledStyles = disabled ? styles?.button?.disabled : noPropObj\n\n  return {\n    ...bookingStyles,\n    content: {\n      ...style,\n      ...disabledStyles?.content,\n    },\n    icon: theme.get(\n      get(bookingStyles, `icon.${iconName}.default`),\n      disabled && get(bookingStyles, `icon.${iconName}.disabled`)\n    ),\n  }\n}\n\n/**\n * Renders the booking button children based on the passed in booking state\n * @param {import('SVModels/session/bookingState').BookingState} model\n * @param {Object} style - Style rules for the children passed from the parent button\n * @param {Object} styles - Booking button child theme styles\n */\nconst RenderBookingState = props => {\n  const { model, style, styles, ...attrs } = props\n  const { displayAmount, icon: Icon, text } = model\n\n  const bookingStyles = useStylesCallback(buildStyles, [\n    model.disabled,\n    Icon && Icon.name,\n    style,\n    styles,\n  ])\n\n  return (\n    <View\n      className={'ef-button-text-main'}\n      style={bookingStyles.main}\n    >\n      { text && (\n        <Text\n          {...attrs}\n          className={`ef-button-text`}\n          style={bookingStyles.content}\n          children={text}\n        />\n      ) }\n      { Icon && <Icon\n        digit={displayAmount}\n        styles={bookingStyles.icon}\n      /> }\n    </View>\n  )\n}\n\n/**\n * Custom hook to check if an attendee should be removed from the session\n * <br/>Then calls the selectSession action\n * @param {import('SVModels/session').Session} session\n * @param {import('SVModels/session/bookingState').BookingState} model\n *\n * @returns {Void}\n */\nconst useSelectSession = (session, model) => {\n  return useCallback(\n    event => {\n      // Check if the mode is single, and the attendee is on the waiting list or already booked\n      // If they are, we want to pass the selectSession action an empty array to remove the attendee from the session\n      const removeAttendee = Boolean(\n        model.mode === BOOKING_MODES.SINGLE &&\n          (model.state === SESSION_BOOKING_STATES.ON_WAITING_LIST ||\n            model.state === SESSION_BOOKING_STATES.SELECTED)\n      )\n\n      // Check if the state is on waiting list, so we know which action to call\n      const actionType =\n        model.state === SESSION_BOOKING_STATES.ON_WAITING_LIST ||\n        model.state === SESSION_BOOKING_STATES.WAITING_LIST\n          ? EVENTS.SESSION_WAITING_LIST_REQUEST\n          : EVENTS.SESSION_BOOKING_REQUEST\n\n      selectSession(session, removeAttendee ? [] : undefined, actionType)\n    },\n    [ session, model ]\n  )\n}\n\n/**\n * Booking button for each session component\n * @param {Object} props\n * @param {import('SVModels/session').Session} props.session\n * @param {Object} styles - Booking button theme styles\n */\nexport const BookingButton = props => {\n  if (!props.session) return null\n\n  const { session } = props\n  const bookingModel = useBookingState(session)\n  const selectSessionCb = useSelectSession(session, bookingModel)\n  const pendingStyles = useStyle('button.evfButton.pending')\n\n  return (\n    (bookingModel?.text && (\n      <EvfButton\n        buttonType={BUTTON_TYPES.SELECT_SESSION}\n        type={bookingModel.state}\n        onClick={selectSessionCb}\n        disabled={bookingModel.disabled}\n        isProcessing={bookingModel.pending}\n        pendingStyles={pendingStyles}\n      >\n        { buttonProps => (\n          <RenderBookingState\n            {...props}\n            {...buttonProps}\n            model={bookingModel}\n          />\n        ) }\n      </EvfButton>\n    )) ||\n    null\n  )\n}\n","import React from 'react'\nimport { PresenterDetails } from 'SVComponents/modals/presenterDetails'\nimport { GroupBooking } from 'SVComponents/modals/groupBooking'\nimport { Filter } from 'SVComponents/modals/filter'\nimport { Alert } from 'SVComponents/modals/alert'\nimport { SessionDetailsModal } from 'SVComponents/modals/sessionDetailsModal'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\nimport { Values } from 'SVConstants'\n\nconst { CATEGORIES } = Values\n\nconst {\n  PRESENTER,\n  GROUP_BOOKING,\n  ALERT,\n  FILTER,\n  SESSION_DETAILS,\n} = Values.MODAL_TYPES\n\n/**\n * Renders a modal if one is flagged as active in the modals store tree\n */\nexport const ModalManager = () => {\n  const { activeModal, visible } = useStoreItems(CATEGORIES.MODALS)\n  return activeModal ? (\n    <ActiveModal\n      modal={activeModal}\n      visible={visible}\n    />\n  ) : null\n}\n\n/**\n * @param {Object} props\n * @param {import('SVModels/Modal').Modal} props.modal - the modal to render\n * @param {boolean} props.visible - whether the modal is visible or not\n */\nconst ActiveModal = ({ modal, visible = true }) => {\n  switch (modal?.type) {\n  case PRESENTER:\n    return <PresenterDetails\n      presenter={modal.data}\n      visible={visible}\n    />\n\n  case GROUP_BOOKING:\n    return <GroupBooking\n      session={modal.data?.session}\n      visible={visible}\n    />\n\n  case ALERT:\n    return (\n      <Alert\n        visible={visible}\n        type={modal.data?.type}\n        title={modal.data?.title}\n        message={modal.data?.message}\n      />\n    )\n\n  case FILTER:\n    return <Filter\n      visible={visible}\n      labels={modal.data?.labels}\n    />\n\n  case SESSION_DETAILS:\n    return (\n      <SessionDetailsModal\n        visible={visible}\n        session={modal.data?.session}\n        labels={modal.data?.labels}\n      />\n    )\n  default:\n    return null\n  }\n}\n","import { dispatch } from 'SVStore'\nimport { ActionTypes, Values } from 'SVConstants'\nimport { itemsState as initialItemsState } from 'SVReducers/initialStates/items'\nimport { noPropObj, shallowEqual } from '@keg-hub/jsutils'\nimport { showAlertModal } from 'SVActions/modals/showAlertModal'\nimport { initSortedAttendees } from 'SVActions/attendees/initSortedAttendees'\nimport { initRestrictedAttendees } from 'SVActions/attendees/initRestrictedAttendees'\nimport { getStore } from 'SVStore'\nimport { applySessionFilters } from 'SVActions/session/filters/applySessionFilters'\n\nconst { CATEGORIES, EVF_CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * defines which sessionAgendaProps need to be mapped to subcategories\n */\nconst subCatMap = {\n  settings: SUB_CATEGORIES.AGENDA_SETTINGS,\n}\n\n/**\n * If alert prop is valid, add a new modal item for alert\n * @param {<import('SVModels/alert').Alert)>} alert\n */\nconst checkAlert = (alert = noPropObj) => {\n  const existingAlert = getStore().getState()?.items?.alert\n\n  // no reason to show the modal again if the alert object has not changed\n  if (shallowEqual(alert, existingAlert)) return\n\n  if (alert?.title && alert?.message) {\n    showAlertModal(alert.message, alert.title)\n  }\n}\n\n/**\n * builds either a SET_ITEMS || UPSERT_ITEM Dispatch payload object based on a given category\n * @param {string} category - some category from the CATEGORIES constants\n * @param {*} value - value to store at the category\n * @returns {object} - of the form { type, payload }\n */\nconst getDispatchPayload = (category, value) => {\n  // displayProperties should go in settings.displayProperties\n  return category === CATEGORIES.DISPLAY_PROPERTIES\n    ? {\n        type: ActionTypes.UPSERT_ITEM,\n        payload: { category: CATEGORIES.SETTINGS, item: value, key: category },\n      }\n    : !subCatMap[category]\n        ? // by default, we use set items, so that if the component is mounted/remounted, data won't be duplicated\n          {\n            type: ActionTypes.SET_ITEMS,\n            payload: { category, items: value ?? initialItemsState[category] },\n          }\n        : // subcategories are upsert-merged, rather than set, since they\n      // might need to be joined with data that was loaded from localStorage,\n      // e.g. agendaSettings.activeDayNumber\n          {\n            type: ActionTypes.UPSERT_ITEM,\n            payload: { category, item: value, key: subCatMap[category] },\n          }\n}\n\n/**\n * push the sessionAgendaProps items to our local state\n * @param {import('SVModels/sessionAgendaProps').SessionAgendaProps} props\n */\nexport const mapSessionInterface = props => {\n  if (!props) return\n\n  // set each events force category in the items store\n  Object.values(EVF_CATEGORIES).map(category => {\n    const action = getDispatchPayload(category, props[category])\n    dispatch(action)\n  })\n\n  checkAlert(props.alert)\n\n  applySessionFilters(props.sessions, props.agendaDays)\n\n  // initialized the restricted attendee list for each session\n  initRestrictedAttendees(props.sessions, props.attendees)\n\n  // initialize the attendeesByTicket lists for each ticket\n  initSortedAttendees(props.attendees, props.tickets, props.bookedTickets)\n}\n","import React from 'react'\nimport { useStyle } from '@keg-hub/re-theme'\nimport { H5 } from '@keg-hub/keg-components'\n\nconst defaultMessage = 'There are no sessions to display for this day'\n\n/**\n * Message to display when the current day has no sessions scheduled\n * @param {Object} props\n * @param {string} props.message\n */\nexport const EmptyDayMessage = ({ message = defaultMessage }) => {\n  const styles = useStyle('emptyDayMessage')\n  return (\n    <H5\n      className={'ef-sessions-empty-text'}\n      style={styles?.main}\n    >\n      { message }\n    </H5>\n  )\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { View } from '@keg-hub/keg-components'\nimport { useStyle } from '@keg-hub/re-theme'\nimport { noPropObj } from '@keg-hub/jsutils'\n\n/**\n * LabelTag - a colored, square label without text\n * @param {Object} props\n * @param {import('SVModels/label').Label} props.label - the label model instance\n * @param {Object} props.styles - styles for the label. Overwrites styles defined in labelTag.main\n */\nexport const LabelTag = ({ label = noPropObj, styles }) => {\n  const tagStyles = useStyle('labelTag.main', styles)\n\n  return (\n    <View\n      className={[ 'ef-label-tag', label.className ]}\n      style={tagStyles}\n    />\n  )\n}\n\nLabelTag.propTypes = {\n  label: PropTypes.object,\n  styles: PropTypes.object,\n}\n","import React from 'react'\nimport { useTheme } from '@keg-hub/re-theme'\nimport PropTypes from 'prop-types'\nimport { View, Text } from '@keg-hub/keg-components'\nimport { getTimeFromDate } from 'SVUtils/dateTime'\nimport { EVFIcons } from 'SVIcons'\n\n/**\n * SessionTime\n * @param {object} props\n * @param {object} props.style - style object\n * @param {string} props.start - ex: 2020-08-03 13:00:00\n * @param {string} props.end - ex: 2020-08-03 13:30:00\n * @param {string} props.military - true if time should be formatted in 24-hour time\n */\nexport const SessionTime = props => {\n  const { style = {}, start, end, military = true } = props\n  const theme = useTheme()\n  const mainStyle = theme.get(theme.get('sessionTime.main'), style)\n  const clockStyle = theme.get('sessionTime.clockIcon')\n  const textStyle = theme.get('sessionTime.timeText')\n\n  return (\n    <View\n      className={`ef-session-time`}\n      style={mainStyle}\n    >\n      <EVFIcons.Clock\n        className={`ef-session-time-clock`}\n        style={clockStyle.main}\n      />\n      <View\n        className={`ef-session-time-container`}\n        style={textStyle.main}\n      >\n        <Text\n          className={`ef-session-time-text`}\n          style={textStyle.content}\n        >\n          { `${getTimeFromDate(start, military)} - ${getTimeFromDate(\n            end,\n            military\n          )}` }\n        </Text>\n      </View>\n    </View>\n  )\n}\n\nSessionTime.propTypes = {\n  style: PropTypes.object,\n  start: PropTypes.string,\n  end: PropTypes.string,\n  military: PropTypes.bool,\n}\n","import React, { useMemo } from 'react'\nimport { Text, Touchable } from '@keg-hub/keg-components'\nimport { useStyle, useTheme, useThemeHover } from '@keg-hub/re-theme'\nimport { noOpObj } from '@keg-hub/jsutils'\nimport { isMobileSize } from 'SVUtils/theme'\nimport { isNative } from 'SVUtils/platform'\n\n/**\n * SessionLink\n * @param {object} props\n * @param {Function} props.onPress\n * @param {string} props.text - text to display\n * @param {object} props.styles\n * @param {string} props.className\n */\nexport const SessionLink = ({ onPress, text, styles, className }) => {\n  const theme = useTheme()\n  const sessionLinkStyles = useStyle('sessionLink.default')\n  const numberOfLines = useMemo(\n    () => (isMobileSize(theme) ? { numberOfLines: 2 } : { numberOfLines: 0 }),\n    [theme]\n  )\n  // apply hover state\n  const [ ref, themeStyle ] = useThemeHover(\n    useStyle(sessionLinkStyles, styles),\n    useStyle(`sessionLink.hover`)\n  )\n\n  return (\n    <Touchable\n      activeOpacity={onPress ? 0.2 : 1}\n      onPress={onPress}\n      style={themeStyle.main}\n      pointerEvents={onPress ? 'auto' : 'none'}\n    >\n      <Text\n        {...(isNative() ? noOpObj : { ref: ref })}\n        {...numberOfLines}\n        style={themeStyle.text}\n        className='ef-session-name'\n      >\n        { text }\n      </Text>\n    </Touchable>\n  )\n}\n","import React, { useState, useCallback } from 'react'\nimport { LabelTag } from 'SVComponents/labels/labelTag'\nimport { LabelList } from 'SVComponents/labels/labelList'\nimport { SessionTime } from 'SVComponents/sessionTime/sessionTime'\nimport { useTheme } from '@keg-hub/re-theme'\nimport PropTypes from 'prop-types'\nimport { SessionLink } from 'SVComponents/sessionLink'\nimport { EvfTextToggle } from 'SVComponents/textToggle'\nimport { View, Text, Drawer, Touchable } from '@keg-hub/keg-components'\nimport { useSessionLocation } from 'SVHooks/models'\nimport { BookingButton } from 'SVComponents/button/bookingButton'\nimport { SessionPresenters } from 'SVComponents/sessionDetails'\n\n/**\n * The content of a grid item when displayed as a row (<= 480px width)\n * @param {Object} props\n * @param {Array} props.labels - the array of label model objects\n * @param {import('SVModels/session').Session} props.session - the session model object\n * @param {Object} props.labelStyles - styles for individual labels\n * @param {boolean} props.militaryTime - if true, use military time for dates\n */\nexport const GridRowContent = props => {\n  const { labels, labelStyles, listStyles, session, militaryTime } = props\n  const theme = useTheme()\n  const [ isOpen, setIsOpen ] = useState(false)\n  const gridRowContentStyles = theme.get('gridItem.gridRowContent')\n  const locationName = useSessionLocation(session)\n  const column2Styles = gridRowContentStyles.column2\n\n  const onToggle = useCallback(event => setIsOpen(!isOpen), [ isOpen, setIsOpen ])\n\n  return (\n    <Touchable\n      style={gridRowContentStyles.main}\n      onPress={onToggle}\n    >\n      <LabelList\n        style={listStyles}\n        itemStyle={labelStyles}\n        LabelComponent={LabelTag}\n        labels={labels}\n      />\n      <View style={column2Styles.main}>\n        <SessionTime\n          style={theme.get('gridItem.sessionTime.main')}\n          start={session.startDateTimeLocal}\n          end={session.endDateTimeLocal}\n          military={militaryTime}\n        />\n        <SessionLink text={session.name} />\n        <Text\n          className={'ef-modal-body-highlight'}\n          style={column2Styles.locationText}\n        >\n          { locationName?.name || '' }\n        </Text>\n        <Drawer toggled={isOpen}>\n          <DrawerContent\n            session={session}\n            styles={column2Styles.drawerContent}\n          />\n        </Drawer>\n      </View>\n    </Touchable>\n  )\n}\n\n/**\n *\n * @param {object} props\n * @param {import('SVModels/session').Session} props.session\n * @param {object} props.styles\n */\nconst DrawerContent = ({ session, styles }) => {\n  return (\n    <View style={styles?.main}>\n      <BookingButton\n        session={session}\n        styles={styles?.bookingButton}\n      />\n      <SessionPresenters session={session} />\n      <EvfTextToggle text={session.summary} />\n    </View>\n  )\n}\n\nGridRowContent.propTypes = {\n  labels: PropTypes.array,\n  session: PropTypes.object,\n  labelComponent: PropTypes.element,\n  labelStyles: PropTypes.object,\n}\n","import React from 'react'\nimport { View, Text } from '@keg-hub/keg-components'\nimport { SessionLink } from 'SVComponents/sessionLink'\nimport { LabelButton } from 'SVComponents/labels/labelButton'\nimport { LabelList } from 'SVComponents/labels/labelList'\nimport { SessionTime } from 'SVComponents/sessionTime/sessionTime'\nimport PropTypes from 'prop-types'\nimport { useTheme } from '@keg-hub/re-theme'\nimport { useFormattedPrice } from 'SVHooks/models/price'\nimport { useCreateModal } from 'SVHooks/modal'\nimport { BookingButton } from 'SVComponents/button/bookingButton'\nimport { Values } from 'SVConstants'\nimport { useSessionLocation, useSessionPresenters } from 'SVHooks/models'\nimport { getPresenterFullName } from 'SVUtils/models'\n\n/**\n * The content of a grid item when displayed as a tile (> 480px width)\n * @param {Object} props\n * @param {Array} props.labels - the array of label model objects\n * @param {import('SVModels/session').Session} props.session - the session model object\n * @param {Object} props.labelStyles - styles for individual labels\n * @param {Func} props.onLabelPress - function called when label is pressed. Receives the pressed label passed to it\n * @param {boolean} props.militaryTime - if true, use military time for dates\n * @param {boolean} props.enableFreeLabel - whether to display 'FREE' on session with no pricing or not\n */\nexport const GridTileContent = props => {\n  const {\n    labels,\n    labelStyles,\n    listStyles,\n    session,\n    onLabelPress,\n    militaryTime,\n    enableFreeLabel,\n  } = props\n\n  const theme = useTheme()\n  const gridTileContentStyles = theme.get('gridItem.gridTileContent')\n  const formattedPrice = useFormattedPrice(session?.price, enableFreeLabel)\n  const displayDetailsModal = useCreateModal(\n    Values.MODAL_TYPES.SESSION_DETAILS,\n    {\n      session,\n      labels,\n    }\n  )\n\n  const location = useSessionLocation(session)\n\n  return (\n    <View\n      className={`ef-grid-tile-content`}\n      style={gridTileContentStyles?.main}\n    >\n      <View style={gridTileContentStyles?.row1?.main}>\n        <SessionTime\n          start={session?.startDateTimeLocal}\n          end={session?.endDateTimeLocal}\n          military={militaryTime}\n        />\n        <Text\n          className={'ef-session-price'}\n          style={gridTileContentStyles?.row1?.price}\n        >\n          { formattedPrice }\n        </Text>\n      </View>\n\n      <LabelList\n        style={listStyles}\n        itemStyle={labelStyles}\n        LabelComponent={LabelButton}\n        labels={labels}\n        onItemPress={onLabelPress}\n      />\n\n      <SessionLink\n        onPress={displayDetailsModal}\n        text={session?.name}\n      />\n\n      { location?.name && (\n        <Text\n          className={'ef-session-location'}\n          style={gridTileContentStyles?.locationText}\n        >\n          { location.name }\n        </Text>\n      ) }\n\n      <PresenterNames\n        session={session}\n        styles={gridTileContentStyles?.presenters}\n      />\n\n      <View style={gridTileContentStyles?.buttonSection?.main}>\n        <BookingButton\n          session={session}\n          styles={gridTileContentStyles?.buttonSection?.bookingButton}\n        />\n      </View>\n    </View>\n  )\n}\n\n/**\n * Displays the presenters in the given session\n * Displays each one as interactable that opens the presenter details modal\n * @param {object} props\n * @param {object} props.style\n * @param {import('SVModels/session').Session} props.session\n */\nconst PresenterNames = React.memo(({ session, styles }) => {\n  const presenters = useSessionPresenters(session)\n\n  return (\n    <View style={styles?.main}>\n      <View style={styles?.container}>\n        { presenters.map(presenter => {\n          return (\n            <PresenterLink\n              key={presenter.identifier}\n              styles={styles?.sessionLink}\n              presenter={presenter}\n            />\n          )\n        }) }\n      </View>\n    </View>\n  )\n})\n\n/**\n * PresenterLink\n * Clickable Presenter name that opens the presenter details modal\n * @param {object} props\n * @param {import('SVModels/presenter').Presenter} props.presenter\n * @param {object} props.styles\n */\nconst PresenterLink = ({ presenter, styles }) => {\n  const displayDetailsModal = useCreateModal(\n    Values.MODAL_TYPES.PRESENTER,\n    presenter\n  )\n  return (\n    <SessionLink\n      className={'ef-sessions-presenter'}\n      styles={styles}\n      key={presenter.identifier}\n      text={getPresenterFullName(presenter)}\n      onPress={displayDetailsModal}\n    />\n  )\n}\n\nGridTileContent.propTypes = {\n  labels: PropTypes.array,\n  session: PropTypes.object,\n  labelComponent: PropTypes.element,\n  onItemPress: PropTypes.func,\n  labelStyles: PropTypes.object,\n}\n","import React, { useMemo } from 'react'\nimport { GridRowContent } from './gridRowContent'\nimport { GridTileContent } from './gridTileContent'\nimport { View } from '@keg-hub/keg-components'\nimport { useTheme } from '@keg-hub/re-theme'\nimport { isMobileSize } from 'SVUtils/theme'\nimport PropTypes from 'prop-types'\nimport { isArr } from '@keg-hub/jsutils'\n\n/**\n * Filter the labels based on the session\n * On mobile view, we display 3 labels max\n * @param {Array<import('SVModels/label').Label>} labels\n * @param {import('SVModels/session').Session} session\n * @param {object} theme\n */\nconst useLabelsForList = (theme, labels, session) =>\n  useMemo(() => {\n    // filter by the session label ids\n    const filteredLabels = isArr(session.labelIdentifiers)\n      ? labels.filter(label =>\n          session.labelIdentifiers.some(id => label.identifier === id)\n        )\n      : []\n    return isMobileSize(theme) ? filteredLabels.slice(0, 3) : filteredLabels\n  }, [ labels, theme, session ])\n\n/**\n * A grid item for the sessions\n * @param {Object} props\n * @param {Array} props.labels - labels for grid item\n * @param {import('SVModels/session').Session} props.session - sesion item\n * @param {boolean} props.militaryTime - if true, use military time for dates\n * @param {Func} props.onLabelPress - function called when label is pressed. Receives the pressed label passed to it\n * @param {boolean} props.enableFreeLabel - whether to display 'FREE' on session with no pricing or not\n */\nexport const GridItem = props => {\n  const {\n    labels = [],\n    session,\n    militaryTime,\n    onLabelPress,\n    enableFreeLabel,\n  } = props\n  if (!session) return null\n\n  const theme = useTheme()\n  const listLabels = useLabelsForList(theme, labels, session)\n  const labelStyles = theme.get('gridItem.label.main')\n  const listStyles = theme.get('gridItem.labelList.main')\n  const GridContent = isMobileSize(theme) ? GridRowContent : GridTileContent\n\n  return (\n    <View\n      className={`ef-grid-item-content`}\n      style={theme.get('gridItem.main')}\n    >\n      <GridContent\n        labels={listLabels}\n        listStyles={listStyles}\n        labelStyles={labelStyles}\n        session={session}\n        militaryTime={militaryTime}\n        onLabelPress={onLabelPress}\n        enableFreeLabel={enableFreeLabel}\n      />\n    </View>\n  )\n}\n\nGridItem.propTypes = {\n  labels: PropTypes.array,\n  session: PropTypes.object,\n}\n","import React, { useMemo } from 'react'\nimport { GridItem } from 'SVComponents/grid/gridItem'\nimport { ItemHeader, Text, View } from '@keg-hub/keg-components'\nimport { sortLabels, isMobileSize } from 'SVUtils'\nimport { useTheme } from '@keg-hub/re-theme'\n\n/**\n *\n * @param {object} param\n * @param {string} timeString\n * @param {object} style - left style theme. theme: gridContainer.content.header.content.left\n */\nconst LeftHeaderText = ({ timeString, style }) => {\n  return (\n    <Text\n      className={`ef-timeslot-header-time-text`}\n      style={style.content.text}\n    >\n      { timeString }\n    </Text>\n  )\n}\n\n/**\n *\n * @param {object} props\n * @param {Date} props.timeBlock - timeblock for this session group\n * @param {Array} props.sessions - sessions within the given timeblock\n * @param {Array<import('SVModels/label').Label>} props.labels - session labels\n * @param {boolean} props.enableFreeLabel - whether to display 'FREE' on session with no pricing or not\n * @param {boolean} props.militaryTime - whether to display time in 12 hr or 24 hr format\n */\nexport const GridContainer = React.memo(props => {\n  const { sessions, labels, timeBlock, enableFreeLabel, militaryTime } = props\n  if (!sessions?.length) return null\n\n  const theme = useTheme()\n  const gridStyles = theme.get('gridContainer')\n  const labelsMemo = useMemo(() => sortLabels(labels), [labels])\n\n  return (\n    <View\n      className={`ef-grid-container`}\n      style={gridStyles.main}\n    >\n      {\n        // only display the time header on web styles\n        !isMobileSize(theme) && (\n          <ItemHeader\n            className={`ef-timeslot-header`}\n            styles={gridStyles.content.header}\n            LeftComponent={\n              <LeftHeaderText\n                timeString={timeBlock}\n                style={gridStyles?.content?.header?.content?.left}\n              />\n            }\n          />\n        )\n      }\n      <View\n        className={`ef-grid-item`}\n        style={gridStyles?.content?.items}\n      >\n        { sessions.map(session => (\n          <GridItem\n            enableFreeLabel={enableFreeLabel}\n            key={session.identifier}\n            labels={labelsMemo}\n            session={session}\n            militaryTime={militaryTime}\n          />\n        )) }\n      </View>\n    </View>\n  )\n})\n","import React from 'react'\nimport { useStylesCallback } from '@keg-hub/re-theme'\nimport { EVFIcons } from 'SVIcons'\nimport { View } from '@keg-hub/keg-components'\nimport PropTypes from 'prop-types'\n\n/**\n * Builds dynamic styles for  `UpdateDayButton`\n * @param {object} theme - retheme object\n * @param {object} extra - extra styles and props\n */\nconst buildStyles = (theme, extra) => {\n  return {\n    ...extra?.style?.icon,\n    opacity: extra.disabled ? 0.4 : 1,\n    cursor: extra.disabled ? 'not-allowed' : 'pointer',\n  }\n}\n\n/**\n * A touchable chevron icon that changes direction based on type\n * @param {Object} props\n * @param {string?} [props.type='increment'] - one of ['decrement', 'increment'] - shows a left icon with 'decrement', and a 'right' icon with 'increment'\n * @param {Object?} [props.styles={}] - optional styles to override defaults { main: {}, content: {} }\n * @param {boolean?} [props.disabled=false] - true if the button should be disabled\n * @param {Function?} props.onDayChange - callback executed when the day changes\n */\nexport const UpdateDayButton = props => {\n  const {\n    type = 'increment',\n    styles = {},\n    disabled = false,\n    onDayChange,\n  } = props\n\n  const iconStyles = useStylesCallback(buildStyles, [ disabled, styles ], {\n    disabled,\n    style: styles,\n  })\n\n  const ChevronIcon =\n    type === 'increment' ? EVFIcons.DayToggleRight : EVFIcons.DayToggleLeft\n\n  return (\n    <View className={`ef-sessions-date-button-${type}`}>\n      <ChevronIcon\n        onPress={!disabled && onDayChange}\n        style={iconStyles}\n        type={type}\n      />\n    </View>\n  )\n}\nUpdateDayButton.propTypes = {\n  type: PropTypes.oneOf([ 'increment', 'decrement' ]),\n  disabled: PropTypes.bool,\n}\n","import React from 'react'\nimport { UpdateDayButton } from './updateDayButton'\nimport { useTheme } from '@keg-hub/re-theme'\nimport { noOp } from '@keg-hub/jsutils'\nimport { View, Text } from '@keg-hub/keg-components'\nimport { isMobileSize } from 'SVUtils/theme'\n/**\n * Simple day toggling component\n * @param {Object} props\n * @param {string} props.date - date shown inside of component\n * @param {number} props.dayNumber - day number shown inside of component\n * @param {boolean} props.disableDecrement - if true, greys out the decrement button\n * @param {boolean} props.disableIncrement - if true, greys out the increment button\n * @param {Function} props.onIncrement -- cb that runs when the increment-day button is pressed\n * @param {Function} props.onDecrement -- cb that runs when the decrement-day button is pressed\n */\nexport const DayToggle = props => {\n  const {\n    date = null,\n    dayText = '',\n    disableDecrement = false,\n    disableIncrement = false,\n    onIncrement = noOp,\n    onDecrement = noOp,\n  } = props\n\n  const theme = useTheme()\n  const mobileSize = isMobileSize(theme)\n  const dayToggleStyles = theme.get('dayToggle')\n\n  return (\n    <View\n      className={'ef-sessions-date-selector'}\n      style={dayToggleStyles?.main}\n    >\n      {!mobileSize && (\n        <UpdateDayButton\n          styles={dayToggleStyles?.content?.decrement}\n          type={'decrement'}\n          disabled={disableDecrement}\n          onDayChange={onDecrement}\n        />\n      )}\n      <Text\n        className={'ef-sessions-date-text'}\n        style={dayToggleStyles?.content?.text}\n        numberOfLines={1}\n      >\n        { dayText }\n      </Text>\n      {!mobileSize && (\n        <UpdateDayButton\n          type={'increment'}\n          styles={dayToggleStyles?.content?.increment}\n          disabled={disableIncrement}\n          onDayChange={onIncrement}\n        />\n      )}\n    </View>\n  )\n}\nDayToggle.propTypes = {}\n","import { ActionTypes, Values } from 'SVConstants'\nimport { dispatch } from 'SVStore'\nimport { validate, isPositive, checkCall } from '@keg-hub/jsutils'\nconst { CATEGORIES, SUB_CATEGORIES } = Values\n\n/**\n * Sets the current, actively-selected day in the agenda\n * @param {Number} newDayNumber - number to change the day to\n * @param {Function?} onChange - optional callback of form (nextDay) => {...}\n *\n */\nexport const setDay = (newDayNumber, onChange) => {\n  const [valid] = validate({ newDayNumber }, { newDayNumber: isPositive })\n  if (!valid) return\n\n  checkCall(onChange, newDayNumber)\n  dispatch({\n    type: ActionTypes.UPSERT_ITEM,\n    payload: {\n      category: CATEGORIES.SETTINGS,\n      key: SUB_CATEGORIES.AGENDA_SETTINGS,\n      item: { activeDayNumber: newDayNumber },\n    },\n  })\n}\n","import { EVFIcons } from 'SVIcons'\nimport { Values } from 'SVConstants'\nimport { useCreateModal } from 'SVHooks/modal'\nimport React, { useCallback, useMemo } from 'react'\nimport { DayToggle } from 'SVComponents/dates/dayToggle'\nimport { useStoreItems } from 'SVHooks/store/useStoreItems'\nimport { ItemHeader, Button, View } from '@keg-hub/keg-components'\nimport { incrementDay, decrementDay } from 'SVActions/session/dates'\nimport { useTheme, useDimensions, useStylesCallback } from '@keg-hub/re-theme'\nimport {\n  applySessionFilters,\n  clearSelectedFilters,\n} from 'SVActions/session/filters'\n\nconst { CATEGORIES, MODAL_TYPES, SUB_CATEGORIES } = Values\n\n/**\n * FilterButton\n * Renders either an Icon or a text button based on current screen dimension\n * @param {object} props\n * @param {object} props.styles\n * @param {Function} props.onClick\n * @param {boolean} props.showIcon\n */\nconst FilterButton = ({ onClick, styles, showIcon }) => {\n  return showIcon ? (\n    <View\n      className={'ef-sessions-filter-button'}\n      style={styles?.filterIcon?.main}\n    >\n      <EVFIcons.Filter\n        className={'ef-sessions-filter-button'}\n        style={styles?.filterIcon?.icon}\n        onPress={onClick}\n        color={styles?.filterIcon?.icon?.color}\n      />\n    </View>\n  ) : (\n    <Button\n      className={'ef-sessions-filter-button'}\n      themePath='button.text.default'\n      styles={styles?.filterButton}\n      onClick={onClick}\n      content={'Filter'}\n    />\n  )\n}\n\n/**\n * Builds the styles for the header right component\n * @param {Object} theme - Global Theme object\n * @param {Object} custom - contains {styles, smallWidth}\n *\n * @returns {Object}\n */\nconst buildStylesHeaderRight = (theme, custom) => {\n  return theme.get(\n    custom.styles,\n    custom.smallWidth && {\n      main: {\n        paddingRight: 0,\n      },\n    }\n  )\n}\n\n/**\n * ItemHeaderRight\n * displays the filter btn and clear btn\n *    hides the clear btn when dimension is small enough\n * @param {object} props\n * @param {object} props.styles - theme path: header.content.right.content\n */\nconst ItemHeaderRight = ({ styles, onClick }) => {\n  const dim = useDimensions()\n  const activeFilters = useStoreItems(\n    `${CATEGORIES.FILTERS}.${SUB_CATEGORIES.ACTIVE_FILTERS}`\n  )\n\n  const smallWidth = dim.width <= 720\n  const showClearButton = dim.width > 520 && Boolean(activeFilters?.length)\n\n  const customStyles = useMemo(\n    () => ({\n      smallWidth,\n      styles,\n    }),\n    [ styles, smallWidth ]\n  )\n\n  const mainStyle = useStylesCallback(\n    buildStylesHeaderRight,\n    [ styles, smallWidth ],\n    customStyles\n  )\n  const clearActiveFilters = useCallback(() => {\n    clearSelectedFilters()\n    applySessionFilters()\n  }, [ applySessionFilters, clearSelectedFilters ])\n\n  return (\n    <View style={mainStyle?.main}>\n      <FilterButton\n        styles={mainStyle}\n        onClick={onClick}\n        showIcon={smallWidth}\n      />\n      { showClearButton && (\n        <Button\n          themePath='button.text.default'\n          styles={mainStyle?.clearAll}\n          content={'Clear'}\n          onClick={clearActiveFilters}\n        />\n      ) }\n    </View>\n  )\n}\n\n/**\n * Component that will hold the day toggle and filter button\n * @param {object} props\n * @param {Array<import('SVModels/label').Label>} props.labels - session labels\n * @param {Function} props.onDayChange - function for handling day changes in the day toggle\n * @param {number} props.currentDay - The active day of the session\n * @param {Object} props.agenda - Metadata for the current days sessions\n * @param {string} props.dayText - override for dayName\n */\nexport const SessionsHeader = React.memo(\n  ({ agenda, currentDay, dayText, onDayChange, labels }) => {\n    const { agendaLength, isLatestDay, isFirstDay, dayName = dayText } = agenda\n    const theme = useTheme()\n    const styles = theme.get('sessions')\n\n    const increment = useCallback(() => incrementDay(onDayChange), [\n      onDayChange,\n    ])\n    const decrement = useCallback(() => decrementDay(onDayChange), [\n      onDayChange,\n    ])\n    const headerStyles = styles.content?.header\n    const displayFilterModal = useCreateModal(MODAL_TYPES.FILTER, { labels })\n\n    return (\n      <View\n        style={headerStyles?.container}\n        className='ef-sessions-header-container'\n      >\n        <ItemHeader\n          styles={headerStyles}\n          className='ef-sessions-header'\n          CenterComponent={\n            <DayToggle\n              dayText={dayName}\n              dayNumber={currentDay}\n              disableDecrement={isFirstDay}\n              disableIncrement={isLatestDay || !agendaLength}\n              onDecrement={decrement}\n              onIncrement={increment}\n            />\n          }\n          RightComponent={\n            <ItemHeaderRight\n              styles={headerStyles?.content?.right?.content}\n              onClick={displayFilterModal}\n            />\n          }\n        />\n      </View>\n    )\n  }\n)\n","import React, { useMemo, useCallback, useRef } from 'react'\nimport { isMobileSize } from 'SVUtils/theme'\nimport { useTheme } from '@keg-hub/re-theme'\nimport { reduceObj, noPropArr } from '@keg-hub/jsutils'\nimport { SessionsDivider } from './sessionsDivider'\nimport { useAgenda } from 'SVHooks/models/useAgenda'\nimport { GridContainer } from 'SVContainers/gridContainer'\nimport { SessionsHeader } from 'SVComponents/sessionsHeader'\nimport { SectionList } from '@keg-hub/keg-components'\nimport { useStylesCallback, useDimensions } from '@keg-hub/re-theme'\nimport { setDay } from 'SVActions/session/dates'\nimport { getWindow } from 'SVUtils/platform/getWindow'\n\n/**\n * Default scroll offset for the section headers based on the size\n * @number\n */\nconst sectionOffset = -45\n\n/**\n * TODO: replace this with keg-core utility once >=v9.5.0 is released\n * @returns {Boolean} true if this react app is in a web environment and also rendered inside of an iframe\n */\nconst isIFrame = () => {\n  const win = getWindow()\n  return win ? win !== win.parent : false\n}\n\n/**\n * Hook to memoize the sessions styles\n * <br/> Also calculates a bottom padding based on gridItem height\n *\n * @returns {Array} - memoized styles for the SectionList\n */\nconst useListStyles = () => {\n  const dims = useDimensions()\n  const { current: initialHeight } = useRef(Math.max(dims.height, 500)) // ensure margin >=500px\n  return useStylesCallback(\n    (theme, styles, height) => {\n      const itemHeight =\n        (theme.get('gridItem')?.main?.minHeight || 300) + sectionOffset\n\n      const viewportHeight = isIFrame() ? initialHeight : height\n\n      return !height\n        ? theme.get('sessionsList')\n        : theme.get('sessionsList', {\n          content: {\n            list: {\n              marginBottom: viewportHeight - itemHeight,\n            },\n          },\n        })\n    },\n    [dims.height]\n  )\n}\n\n/**\n * Hook to memoize the sessions for a day, and add a key\n * @param {Array} sessions - group of sessions by day\n * @param {Array} agendaDays\n *\n * @returns {Array} - memoized sessions in SectionList required format\n */\nconst useSessionsSections = (sessions, agendaDays = noPropArr) => {\n  return useMemo(() => {\n    return reduceObj(\n      sessions,\n      (dayNum, timeBlocks, sections) => {\n        sections.push({\n          dayNum,\n          // Is the first section if no sections have been added\n          first: !sections.length,\n          // Is the last section, if total sections === total sessions minus one\n          last: Object.keys(sessions).length - 1 === sections.length,\n          // Store the text to displace above each day\n          dayText: agendaDays.find(\n            agendaDay => agendaDay.dayNumber === parseInt(dayNum)\n          )?.dayName,\n          data: timeBlocks.map(timeBlock => {\n            timeBlock.key = `${dayNum}-${timeBlock.timeBlock}`\n            return timeBlock\n          }),\n        })\n\n        return sections\n      },\n      []\n    )\n  }, [ sessions, agendaDays ])\n}\n\n/**\n * Hook to memoize an onScrollChange callback\n * @param {Array} sections - group of sessions by day\n * @param {number} currentDay - Active day of sessions being rendered\n * @param {function} onDayChange - Callback to be called when the active day changes\n *\n * @returns {Array} - memoized sessions in SectionList required format\n */\nconst useOnScrollChange = (sections, currentDay, onDayChange) => {\n  return useCallback(\n    nextDayStr => {\n      const nextDay = parseInt(nextDayStr)\n      setDay(nextDay, onDayChange)\n    },\n    [ sections, currentDay, onDayChange ]\n  )\n}\n\n/**\n * SessionList - Container for all sessions separated by day\n * @param {object} props\n * @param {Array<import('SVModels/label').Label>} props.labels - session labels\n * @param {Array} props.onDayChange - Callback method for session day changes\n * @param {Array} props.sessions - group of sessions by day\n * @param {Object} props.settings - Sessions settings from redux store\n * @param {boolean} props.enableFreeLabel - whether to display 'FREE' on session with no pricing or not\n * @param {boolean} props.militaryTime - whether to display time in 12 hr or 24 hr format\n *\n * @returns {Component}\n */\nexport const SessionsList = props => {\n  const { settings, sessions, onDayChange, ...itemProps } = props\n  const currentDay = settings.agendaSettings.activeDayNumber || 1\n\n  const theme = useTheme()\n  const agenda = useAgenda()\n  const styles = useListStyles()\n  const isMobile = isMobileSize(theme)\n  const sections = useSessionsSections(sessions, agenda?.agendaDays)\n  const onScrollSectionChange = useOnScrollChange(\n    sections,\n    currentDay,\n    onDayChange\n  )\n\n  return (\n    <SectionList\n      styles={styles}\n      sections={sections}\n      activeSection={currentDay}\n      indexSectionHeaderBy={'dayNum'}\n      sectionChangeOffset={sectionOffset}\n      onScrollSectionChange={onScrollSectionChange}\n      renderItem={({ item }) => <GridContainer\n        {...item}\n        {...itemProps}\n      />}\n      renderListHeader={({ onSectionChange: onDayChange }) => (\n        <SessionsHeader\n          agenda={agenda}\n          currentDay={currentDay}\n          labels={itemProps.labels}\n          onDayChange={onDayChange}\n        />\n      )}\n      renderSectionHeader={({ section, styles }) => (\n        <SessionsDivider\n          styles={styles}\n          first={section.first}\n          last={section.last}\n          isMobile={isMobile}\n          dayNum={section?.dayNum}\n          dayText={section?.dayText}\n          hasSessions={Boolean(section?.data.length)}\n        />\n      )}\n    />\n  )\n}\n","function isAbsolute(pathname) {\n  return pathname.charAt(0) === '/';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node's url.parse\nfunction resolvePathname(to, from) {\n  if (from === undefined) from = '';\n\n  var toParts = (to && to.split('/')) || [];\n  var fromParts = (from && from.split('/')) || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return '/';\n\n  var hasTrailingSlash;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === '.' || last === '..' || last === '';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === '.') {\n      spliceOne(fromParts, i);\n    } else if (part === '..') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');\n\n  if (\n    mustEndAbs &&\n    fromParts[0] !== '' &&\n    (!fromParts[0] || !isAbsolute(fromParts[0]))\n  )\n    fromParts.unshift('');\n\n  var result = fromParts.join('/');\n\n  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';\n\n  return result;\n}\n\nexport default resolvePathname;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport resolvePathname from 'resolve-pathname';\nimport valueEqual from 'value-equal';\nimport warning from 'tiny-warning';\nimport invariant from 'tiny-invariant';\n\nfunction addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n}\nfunction stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;\n}\nfunction stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n  var hashIndex = pathname.indexOf('#');\n\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n}\nfunction createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n  var path = pathname || '/';\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : \"?\" + search;\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : \"#\" + hash;\n  return path;\n}\n\nfunction createLocation(path, state, key, currentLocation) {\n  var location;\n\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n}\nfunction locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n}\n\nfunction createTransitionManager() {\n  var prompt = null;\n\n  function setPrompt(nextPrompt) {\n    process.env.NODE_ENV !== \"production\" ? warning(prompt == null, 'A history supports only one prompt at a time') : void 0;\n    prompt = nextPrompt;\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  }\n\n  function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : void 0;\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  }\n\n  var listeners = [];\n\n  function appendListener(fn) {\n    var isActive = true;\n\n    function listener() {\n      if (isActive) fn.apply(void 0, arguments);\n    }\n\n    listeners.push(listener);\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  }\n\n  function notifyListeners() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(void 0, args);\n    });\n  }\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\nfunction getConfirmation(message, callback) {\n  callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\n\nfunction supportsHistory() {\n  var ua = window.navigator.userAgent;\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n  return window.history && 'pushState' in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\n\nfunction supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\n\nfunction supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\n\nfunction isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n}\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nfunction getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\n\n\nfunction createBrowserHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Browser history needs a DOM') : invariant(false) : void 0;\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n  var _props = props,\n      _props$forceRefresh = _props.forceRefresh,\n      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var path = pathname + search + hash;\n    process.env.NODE_ENV !== \"production\" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path, state, key);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n    handlePop(getDOMLocation(event.state));\n  }\n\n  function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  }\n\n  var forceNextPop = false;\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  }\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key]; // Public interface\n\n  function createHref(location) {\n    return basename + createPath(location);\n  }\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.pushState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex + 1);\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history') : void 0;\n        window.location.href = href;\n      }\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n      if (canUseHistory) {\n        globalHistory.replaceState({\n          key: key,\n          state: state\n        }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n          setState({\n            action: action,\n            location: location\n          });\n        }\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history') : void 0;\n        window.location.replace(href);\n      }\n    });\n  }\n\n  function go(n) {\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(PopStateEvent, handlePopState);\n      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nvar HashChangeEvent$1 = 'hashchange';\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nfunction stripHash(url) {\n  var hashIndex = url.indexOf('#');\n  return hashIndex === -1 ? url : url.slice(0, hashIndex);\n}\n\nfunction getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n}\n\nfunction pushHashPath(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHashPath(path) {\n  window.location.replace(stripHash(window.location.href) + '#' + path);\n}\n\nfunction createHashHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  !canUseDOM ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Hash history needs a DOM') : invariant(false) : void 0;\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n  var _props = props,\n      _props$getUserConfirm = _props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = _props.hashType,\n      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n  function getDOMLocation() {\n    var path = decodePath(getHashPath());\n    process.env.NODE_ENV !== \"production\" ? warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : void 0;\n    if (basename) path = stripBasename(path, basename);\n    return createLocation(path);\n  }\n\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  function locationsAreEqual$$1(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n  }\n\n  function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n      handlePop(location);\n    }\n  }\n\n  function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({\n            action: action,\n            location: location\n          });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  }\n\n  function revertPop(fromLocation) {\n    var toLocation = history.location; // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n    if (toIndex === -1) toIndex = 0;\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n    if (fromIndex === -1) fromIndex = 0;\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  } // Ensure the hash is encoded properly before doing anything else.\n\n\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)]; // Public interface\n\n  function createHref(location) {\n    var baseTag = document.querySelector('base');\n    var href = '';\n\n    if (baseTag && baseTag.getAttribute('href')) {\n      href = stripHash(window.location.href);\n    }\n\n    return href + '#' + encodePath(basename + createPath(location));\n  }\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Hash history cannot push state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex + 1);\n        nextPaths.push(path);\n        allPaths = nextPaths;\n        setState({\n          action: action,\n          location: location\n        });\n      } else {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack') : void 0;\n        setState();\n      }\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(state === undefined, 'Hash history cannot replace state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    process.env.NODE_ENV !== \"production\" ? warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;\n    globalHistory.go(n);\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  var listenerCount = 0;\n\n  function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1 && delta === 1) {\n      window.addEventListener(HashChangeEvent$1, handleHashChange);\n    } else if (listenerCount === 0) {\n      window.removeEventListener(HashChangeEvent$1, handleHashChange);\n    }\n  }\n\n  var isBlocked = false;\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  }\n\n  function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  }\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */\n\n\nfunction createMemoryHistory(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var _props = props,\n      getUserConfirmation = _props.getUserConfirmation,\n      _props$initialEntries = _props.initialEntries,\n      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,\n      _props$initialIndex = _props.initialIndex,\n      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,\n      _props$keyLength = _props.keyLength,\n      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n  var transitionManager = createTransitionManager();\n\n  function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n    transitionManager.notifyListeners(history.location, history.action);\n  }\n\n  function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  }\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\n  }); // Public interface\n\n  var createHref = createPath;\n\n  function push(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n      var nextEntries = history.entries.slice(0);\n\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  }\n\n  function replace(path, state) {\n    process.env.NODE_ENV !== \"production\" ? warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : void 0;\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n      history.entries[history.index] = location;\n      setState({\n        action: action,\n        location: location\n      });\n    });\n  }\n\n  function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  }\n\n  function goBack() {\n    go(-1);\n  }\n\n  function goForward() {\n    go(1);\n  }\n\n  function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  }\n\n  function block(prompt) {\n    if (prompt === void 0) {\n      prompt = false;\n    }\n\n    return transitionManager.setPrompt(prompt);\n  }\n\n  function listen(listener) {\n    return transitionManager.appendListener(listener);\n  }\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n  return history;\n}\n\nexport { createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath };\n","import { loadFromLocalStorage } from 'SVUtils/storage'\nimport { Values, ActionTypes } from 'SVConstants'\nimport { dispatch } from 'SVStore'\nconst { LOCAL_STORAGE_KEYS } = Values\n\n/**\n * Tap override of app init action, which loads values from local storage, then\n * dispatches the init value\n */\nexport const initSessions = async () => {\n  const loadPromises = LOCAL_STORAGE_KEYS.map(path =>\n    loadFromLocalStorage({ path })\n  )\n  await Promise.all(loadPromises)\n  dispatch({\n    type: ActionTypes.SESSIONS_INIT,\n    initialized: true,\n  })\n  return Promise.resolve()\n}\n","export const mediumText =\n  'Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of \"de Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32.'\n\nexport const longText =\n  'Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of \"de Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32. Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of \"de Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32. Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of \"de Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32. Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32. Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of \"de Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32. Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32. Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of \"de Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32. Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32. Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of \"de Finibus Bonorum et Malorum\" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, \"Lorem ipsum dolor sit amet..\", comes from a line in section 1.10.32.'\n","import { longText } from './text'\n\nexport default {\n  displayProperties: {\n    dateFormat: 'dd/MM/yyyy', // can be \"dd/MM/yyyy\" | \"MM/dd/yyyy\" | \"yyyy-MM-dd\"\n    timeFormat: '12' // can be '12' or '24'\n  },\n  agendaDays: [\n    {\n      dayNumber: 1,\n      date: '2020-07-17',\n      dayName: 'Day 1 - Introduction day',\n    },\n    {\n      dayNumber: 2,\n      date: '2020-07-18',\n      dayName: 'Custom day name 2',\n    },\n    {\n      dayNumber: 3,\n      date: '2020-07-19',\n      dayName: 'This is day 3',\n    },\n    {\n      dayNumber: 4,\n      date: '2020-07-20',\n      dayName: 'Day 4',\n    },\n  ],\n  settings: {\n    showLocationInAgenda: true,\n    showPresentersInAgenda: true,\n  },\n  presenters: [\n    {\n      identifier: '1',\n      title: 'Mr',\n      firstname: 'Frank',\n      lastname: 'Macloud',\n      email: 'f.macloud@test.tes',\n      jobtitle: 'Careers Advisor',\n      company: 'Infinite Wealth',\n      photographUrl:\n        'https://47ddc71556b359d028bd-d91a48d103994bcfc502e0439b859d74.ssl.cf3.rackcdn.com/ef-iij5tpq56zja/noevent/personal/679/wvBcFJAn5jU0wAzmq3g6553149064133/avatar_people_person_business_.jpg',\n      biography:\n        'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.',\n    },\n    {\n      identifier: '2',\n      title: 'Ms',\n      firstname: 'Cynthia',\n      lastname: \"O'Connor\",\n      email: \"c.o'connor@test.tes\",\n      jobtitle: 'Marketing Manager',\n      company: 'Scaffolding Solutions Ltd',\n      biography: '',\n    },\n    {\n      identifier: '3',\n      title: 'Mrs',\n      firstname: 'Franky',\n      lastname: 'Macloudy',\n      email: 'f.macloud@test.tes',\n      jobtitle: 'Careers Advisor',\n      company: 'Infinite Wealth',\n      photographUrl:\n        'https://47ddc71556b359d028bd-d91a48d103994bcfc502e0439b859d74.ssl.cf3.rackcdn.com/ef-iij5tpq56zja/noevent/personal/679/wvBcFJAn5jU0wAzmq3g6553149064133/avatar_people_person_business_.jpg',\n      biography: longText,\n    },\n    {\n      identifier: '4',\n      firstname: 'Bobby',\n      lastname: 'Flay',\n      email: 'b_flay@gmail.com',\n      jobtitle: 'Janitor',\n      company: 'Simpleview',\n      biography: longText,\n    },\n  ],\n  labels: [\n    {\n      identifier: '1',\n      name: 'Important',\n      className: 'ef-agenda-label-201',\n    },\n    {\n      identifier: '2',\n      name: 'Big Data',\n      className: 'ef-agenda-label-202',\n    },\n    {\n      identifier: '3',\n      name: 'Popular',\n      className: 'ef-agenda-label-203',\n    },\n    {\n      identifier: '4',\n      name: 'Analytics',\n      className: 'ef-agenda-label-204',\n    },\n    {\n      identifier: '5',\n      name: 'Machine Learning',\n      className: 'ef-agenda-label-205',\n    },\n    {\n      identifier: '6',\n      name: 'Breaks',\n      className: 'ef-agenda-label-206',\n    },\n  ],\n  locations: [\n    {\n      identifier: '1',\n      name: 'The Atrium',\n    },\n    {\n      identifier: '2',\n      name: 'Main Hall',\n    },\n  ],\n  sessions: [\n    {\n      allowBooking: false,\n      identifier: '1',\n      name:\n        'session with presenters and labels session with presenters and labels session with presenters and labels session with presenters and labels',\n      summary:\n        'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. ',\n      dayNumber: 1,\n      startDateTimeLocal: '2020-08-03 09:00:00',\n      endDateTimeLocal: '2020-08-03 13:30:00',\n      presenterIdentifiers: [ '1', '2' ],\n      labelIdentifiers: [ '1', '2' ],\n      locationIdentifier: '1',\n      liveVideoUrl: 'https://us02web.zoom.us/j/1234',\n      recordedVideoUrl: 'https://www.youtube.com/watch?v=21X5lGlDOfg',\n      restrictToAttendeeCategories: [],\n      capacity: {\n        isUnlimited: true,\n      },\n      price: {\n        currency: 'USD',\n        amount: 923.0,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '2',\n      name: 'session at same time other session with presenters and labels',\n      summary: '',\n      dayNumber: 1,\n      startDateTimeLocal: '2020-08-03 13:00:00',\n      endDateTimeLocal: '2020-08-03 13:30:00',\n      presenterIdentifiers: [],\n      labelIdentifiers: ['3'],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: [],\n      capacity: {\n        isUnlimited: true,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '3',\n      name: 'Session on day 2 - limited capacity',\n      summary: '',\n      dayNumber: 2,\n      startDateTimeLocal: '2020-08-04 09:00:00',\n      endDateTimeLocal: '2020-08-04 09:30:00',\n      presenterIdentifiers: [],\n      labelIdentifiers: [ '3', '4' ],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: [ '1', '2' ],\n      capacity: {\n        isUnlimited: false,\n        remainingPlaces: 1,\n        isWaitingListAvailable: true,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '13',\n      name: 'Session on day 2, limited capacity, no waiting list',\n      summary: '',\n      dayNumber: 2,\n      startDateTimeLocal: '2020-08-04 09:15:00',\n      endDateTimeLocal: '2020-08-04 09:30:00',\n      presenterIdentifiers: [],\n      labelIdentifiers: [],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: [ '1', '2' ],\n      capacity: {\n        isUnlimited: false,\n        remainingPlaces: 0,\n        isWaitingListAvailable: false,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '4',\n      name: 'Session on day 2 limited capacity, has waiting list',\n      summary: '',\n      dayNumber: 2,\n      startDateTimeLocal: '2020-08-04 10:00:00',\n      endDateTimeLocal: '2020-08-04 10:30:00',\n      presenterIdentifiers: ['4'],\n      labelIdentifiers: [],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: [],\n      capacity: {\n        isUnlimited: false,\n        remainingPlaces: 3,\n        isWaitingListAvailable: true,\n      },\n    },\n    {\n      allowBooking: false,\n      identifier: '5',\n      name: 'Session on day 2 full, has waiting list',\n      summary: '',\n      dayNumber: 2,\n      startDateTimeLocal: '2020-08-04 11:00:00',\n      endDateTimeLocal: '2020-08-04 11:30:00',\n      presenterIdentifiers: [],\n      labelIdentifiers: [],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: [],\n      capacity: {\n        isUnlimited: false,\n        remainingPlaces: 0,\n        isWaitingListAvailable: true,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '6',\n      name: 'Session on day 2 restricted to attendee category',\n      summary: '',\n      dayNumber: 2,\n      startDateTimeLocal: '2020-08-04 11:00:00',\n      endDateTimeLocal: '2020-08-04 11:30:00',\n      presenterIdentifiers: [],\n      labelIdentifiers: [],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: ['1'],\n      capacity: {\n        isUnlimited: true,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '7',\n      name: 'Session on day 2 Demo 1',\n      summary: '',\n      dayNumber: 2,\n      startDateTimeLocal: '2020-08-04 11:00:00',\n      endDateTimeLocal: '2020-08-04 11:45:00',\n      presenterIdentifiers: [],\n      labelIdentifiers: [],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: ['1'],\n      capacity: {\n        isUnlimited: false,\n        remainingPlaces: 1,\n        isWaitingListAvailable: false,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '8',\n      name:\n        'Session on day 2 Demo 2: super long name. Something different that is very complicated to describe',\n      summary: '',\n      dayNumber: 2,\n      startDateTimeLocal: '2020-08-04 11:00:00',\n      endDateTimeLocal: '2020-08-04 11:30:00',\n      presenterIdentifiers: [],\n      labelIdentifiers: ['6'],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: ['1'],\n      capacity: {\n        isUnlimited: true,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '9',\n      name: 'Session on day 2 Demo 3',\n      summary: '',\n      dayNumber: 2,\n      startDateTimeLocal: '2020-08-04 15:00:00',\n      endDateTimeLocal: '2020-08-04 16:30:00',\n      presenterIdentifiers: [],\n      labelIdentifiers: [ '1', '6' ],\n      locationIdentifier: '2',\n      liveVideoUrl: '',\n      recordedVideoUrl: '',\n      restrictToAttendeeCategories: ['1'],\n      capacity: {\n        isUnlimited: true,\n      },\n    },\n    {\n      allowBooking: true,\n      identifier: '10',\n      name: 'Test session day 3',\n      summary: 'This is a session with both presenters and labels',\n      dayNumber: 3,\n      startDateTimeLocal: '2020-08-03 09:00:00',\n      endDateTimeLocal: '2020-08-03 13:30:00',\n      presenterIdentifiers: [ '1', '2' ],\n      labelIdentifiers: [ '1', '2' ],\n      locationIdentifier: '1',\n      liveVideoUrl: 'https://us02web.zoom.us/j/1234',\n      recordedVideoUrl: 'https://www.youtube.com/watch?v=21X5lGlDOfg',\n      restrictToAttendeeCategories: [],\n      capacity: {\n        isUnlimited: false,\n        isWaitingListAvailable: true,\n        remainingPlaces: 0,\n      },\n      price: {\n        currency: 'USD',\n        amount: 923.0,\n      },\n    },\n    {\n      allowBooking: false,\n      identifier: '11',\n      name: 'Zerista session day 3',\n      summary: 'This is a session with both presenters and labels',\n      dayNumber: 3,\n      startDateTimeLocal: '2020-08-03 09:00:00',\n      endDateTimeLocal: '2020-08-03 13:30:00',\n      presenterIdentifiers: [ '1', '2' ],\n      labelIdentifiers: [ '1', '2' ],\n      locationIdentifier: '1',\n      liveVideoUrl: 'https://us02web.zoom.us/j/1234',\n      recordedVideoUrl: 'https://www.youtube.com/watch?v=21X5lGlDOfg',\n      restrictToAttendeeCategories: [],\n      capacity: {\n        isUnlimited: true,\n      },\n      price: {\n        currency: 'USD',\n        amount: 923.0,\n      },\n    },\n    {\n      allowBooking: false,\n      identifier: '12',\n      name: 'Zerista session day 3',\n      summary: 'This is a session with both presenters and labels',\n      dayNumber: 3,\n      startDateTimeLocal: '2020-08-03 09:00:00',\n      endDateTimeLocal: '2020-08-03 13:30:00',\n      presenterIdentifiers: [ '1', '2' ],\n      labelIdentifiers: [ '1', '2' ],\n      locationIdentifier: '1',\n      liveVideoUrl: 'https://us02web.zoom.us/j/1234',\n      recordedVideoUrl: 'https://www.youtube.com/watch?v=21X5lGlDOfg',\n      restrictToAttendeeCategories: [],\n      capacity: {\n        isUnlimited: false,\n        remainingPlaces: 100,\n        isWaitingListAvailable: false,\n      },\n      price: {\n        currency: 'USD',\n        amount: 923.0,\n      },\n    },\n  ],\n  attendees: [\n    {\n      bookedTicketIdentifier: '1',\n      name: 'Mr Frank Smith',\n      attendeeCategoryIdentifier: '1',\n      bookedDays: [ 1, 2 ],\n      bookedSessions: [],\n    },\n    {\n      bookedTicketIdentifier: '2',\n      name: \"Mrs Penelope O'Connor the Second\",\n      attendeeCategoryIdentifier: '2',\n      bookedDays: [2],\n      bookedSessions: [],\n      waitingListSessions: ['3'],\n    },\n    {\n      bookedTicketIdentifier: '3',\n      name: 'Dr Lucy Jones',\n      attendeeCategoryIdentifier: '1',\n      bookedDays: [ 1, 2 ],\n      bookedSessions: [ '1', '3', '5' ],\n    },\n    {\n      bookedTicketIdentifier: '4',\n      name: 'Pepe Silvia',\n      attendeeCategoryIdentifier: '1',\n      bookedDays: [ 2 ],\n      bookedSessions: [ '13' ],\n    },\n    {\n      bookedTicketIdentifier: '5',\n      name: 'Vic Vinegar',\n      attendeeCategoryIdentifier: '3',\n      bookedDays: [3],\n      bookedSessions: [],\n    },\n    {\n      bookedTicketIdentifier: '6',\n      name: 'Hugh Honey',\n      attendeeCategoryIdentifier: '3',\n      bookedDays: [3],\n      bookedSessions: [],\n    },\n    {\n      bookedTicketIdentifier: '7',\n      attendeeCategoryIdentifier: '1',\n      bookedDays: [ 1, 2 ],\n      bookedSessions: [ '3', '5' ],\n    },\n    {\n      bookedTicketIdentifier: '8',\n      attendeeCategoryIdentifier: '1',\n      bookedDays: [ 1, 2 ],\n      bookedSessions: [ '3', '5' ],\n    },\n  ],\n  bookedTickets: [\n    { identifier: '1', ticketIdentifier: '34' },\n    { identifier: '2', ticketIdentifier: '34' },\n    { identifier: '3', ticketIdentifier: '37' },\n    { identifier: '4', ticketIdentifier: '38' },\n    { identifier: '7', ticketIdentifier: '38' },\n    { identifier: '8', ticketIdentifier: '37' },\n    {\n      identifier: '9',\n      ticketIdentifier: '39',\n      bookedSubTickets: [\n        { identifier: '5', ticketIdentifier: '38' },\n        { identifier: '6', ticketIdentifier: '37' },\n      ],\n    },\n  ],\n  tickets: [\n    {\n      ticketType: 'person',\n      identifier: '34',\n      name: 'Regular Attendee',\n      displayOrder: 1,\n    },\n    {\n      ticketType: 'person',\n      identifier: '37',\n      name: 'VIP',\n      displayOrder: 4,\n    },\n    {\n      ticketType: 'group',\n      identifier: '38',\n      name: 'Group',\n      displayOrder: 3,\n    },\n    {\n      ticketType: 'group',\n      identifier: '40',\n      name: 'Family Ticket',\n      displayOrder: 2,\n    },\n  ],\n  alert: {\n    message: '',\n    title: '',\n    type: 'error',\n  },\n}\n","/**\n * IMPORTANT - should not be imported into the main sessions component export\n * This is for DEVELOPMENT only\n * https://docs.google.com/document/d/1oTOhGc1fpG0VhqXTq4ZumceZWoi1ln17wFVxG9SmlDE\n */\nimport React from 'react'\nimport { Button } from 'reactstrap'\n\n/**\n * Maps the internal button type to a default bootstrap button color prop\n * Only used when developing the session component\n */\nconst typeToColorMap = {\n  selectSession: 'info',\n  modalPrimary: 'primary',\n  modalSecondary: 'secondary',\n}\n\n\n/**\n * This is a demo button component. The real component gets passed in from the Sessions Component consumer\n * This is basically just a HOC, but called as a function directly\n *\n * It will return a functional component to be passed into the Session Component as a prop\n *\n * This allows the EU team to define the button in what ever format is needed, including passing in the props\n * While at the same time, it allows the session component to define the content of the button\n */\nexport const EvfButton = ({\n  children,\n  disabled,\n  buttonType,\n  className,\n  onClick,\n  ...props\n}) => {\n  return (\n    <Button\n      className={className}\n      onClick={onClick}\n      disabled={disabled}\n      color={typeToColorMap[buttonType]}\n      data-button-type={buttonType}\n    >\n      { children }\n    </Button>\n  )\n}\n","import React, {useState, useMemo, useCallback} from 'react'\nimport Sessions from '@keg-hub/tap-evf-sessions'\nimport testData from './mocks/testData'\nimport { EvfButton } from './mocks/evfButton'\nimport { evfModalBuilder } from './mocks/evfModalBuilder'\nimport { useRGA4 } from '@keg-hub/rga4'\n\nconst onBookingRequest = (sessionId, ids) => {\n  console.log('Booking request for session ', sessionId, 'with attendees: ', ids)\n  return new Promise(resolve => setTimeout(resolve, 1000))\n}\n\nconst onWaitingRequest = (sessionId, ids) => {\n  console.log('Booking request for session ', sessionId, 'with attendees: ', ids)\n  return new Promise(resolve => setTimeout(resolve, 1000))\n}\n\nexport const EvfSessions = props => {\n  const rga4 = useRGA4()\n\n  const [modalParentProps] = useState({ className: 'evf-modal' })\n\n  const SessionsModal = useMemo(() => {\n    return evfModalBuilder(modalParentProps)\n  }, [modalParentProps])\n\n  const bookingRequest = useCallback((sessionId, ids) => {\n    rga4.event({\n      name: 'booking_request',\n      session: sessionId,\n      ids: ids,\n    })\n    return onBookingRequest(sessionId, ids)\n  }, [rga4])\n\n  const waitingRequest = useCallback((sessionId, ids) => {\n    rga4.event({\n      name: 'waiting_request',\n      session: sessionId,\n      ids: ids,\n    })\n    return onWaitingRequest(sessionId, ids)\n  }, [rga4])\n\n  return <Sessions \n    showVersion={true}\n    onSessionBookingRequest={bookingRequest}\n    onSessionWaitingListRequest={waitingRequest}\n    sessionAgendaProps={testData}\n    ButtonComponent={EvfButton}\n    ModalComponent={SessionsModal}\n  />\n}\n\n","// IMPORTANT - should not be imported into the main sessions component export\n// This is for DEVELOPMENT only\n\nimport React from 'react'\nimport { Modal, ModalHeader, ModalBody, ModalFooter } from 'reactstrap'\n\n/*\n * This is a demo modal component. The real component gets passed in from the Sessions Component consumer\n * This is basically just a HOC, but called as a function directly\n *\n * It will return a functional component to be passed into the Session Component as a prop\n *\n * This allows the EU team to define the modal in what ever format is needed, including passing in the props\n * While at the same time, it allows the session component to define the content of the modal\n */\nexport const evfModalBuilder = parentProps => {\n  // Returns a function which should be passed as a prop to the Sessions Component\n  // Will replace the current internal Modal of the Sessions Component\n  return ({ modalHeader, modalBody, modalFooter, toggle, isOpen }) => {\n    return (\n      // Render the Modal component as needed with the passed in parent props\n      // Call the renderProp passed in from the session component\n      // The isOpen and toggle props should be owned by the Session component ( US Team )\n      // All other modal parentProps come from the X5 app ( EU Team )\n      // The toggle and isOpen props ( US Team ) should override the parentProps ( EU Team )\n      <Modal\n        {...parentProps}\n        isOpen={isOpen}\n        toggle={toggle}\n      >\n        { modalHeader && <ModalHeader>{ modalHeader }</ModalHeader> }\n        { modalBody && <ModalBody>{ modalBody }</ModalBody> }\n        { modalFooter && <ModalFooter>{ modalFooter }</ModalFooter> }\n      </Modal>\n    )\n  }\n}\n","import React from 'react'\nimport { RGA4Provider } from '@keg-hub/rga4'\nimport { EvfSessions } from './EvfSessions'\n\nimport \"bootstrap/dist/css/bootstrap.min.css\"\n\nconst ga4Config = { debug_mode: true }\n\nconst App = () => {\n  return (\n    <RGA4Provider code={'G-W0DPH3TXHV'} config={ga4Config} >\n      <EvfSessions />\n    </RGA4Provider>\n  )\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}